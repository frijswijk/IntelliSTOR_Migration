<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report/Spoolfile Viewer</title>
    <style>
        /* ===========================
           CSS VARIABLES (THEMING)
           =========================== */
        /* Dark theme (default) */
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --accent-primary: #e94560;
            --text-primary: #e0e0e0;
            --text-secondary: #b8b8b8;
            --report-bg: #0a0a0a;
            --report-text: #e0e0e0;
            --border-color: #0f3460;
            --highlight-color: #f1c40f;
            --highlight-bg: #ffff00;
            --highlight-text: #000;
            --zebra-color1: #1a1a2e;
            --zebra-color2: #0f3460;
            --ruler-text: #888;
        }

        /* Light theme */
        body.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e0e0e0;
            --accent-primary: #d63447;
            --text-primary: #333333;
            --text-secondary: #666666;
            --report-bg: #ffffff;
            --report-text: #333333;
            --border-color: #cccccc;
            --highlight-color: #f39c12;
            --highlight-bg: #ffff00;
            --highlight-text: #000;
            --ruler-text: #666;
        }

        /* High Contrast theme - "Green Screen" terminal style */
        body.high-contrast {
            --bg-primary: #000000;
            --bg-secondary: #000000;
            --bg-tertiary: #001100;
            --accent-primary: #00ff00;
            --text-primary: #00ff00;
            --text-secondary: #00ff00;
            --report-bg: #000000;
            --report-text: #00ff00;
            --border-color: #00ff00;
            --highlight-color: #00ff00;
            --highlight-bg: #ffffff;
            --highlight-text: #000000;
            --ruler-text: #00ff00;
        }

        body.high-contrast .report-display {
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 2px var(--report-text);
        }

        body.high-contrast .ruler .decade-marker {
            color: #00ffff;
            font-weight: bold;
        }

        body.high-contrast .search-highlight {
            background: #ffff00;
            color: #000000;
            outline: 2px solid #ffffff;
        }

        /* High contrast button styling - green outline with black background */
        body.high-contrast .upload-btn,
        body.high-contrast .settings-btn,
        body.high-contrast .case-sensitive-btn,
        body.high-contrast .line-toggle,
        body.high-contrast .line-toggle-ruler {
            background: #000000;
            color: #00ff00;
            border: 2px solid #00ff00;
        }

        body.high-contrast .upload-btn:hover,
        body.high-contrast .settings-btn:hover,
        body.high-contrast .case-sensitive-btn:hover,
        body.high-contrast .line-toggle:hover,
        body.high-contrast .line-toggle-ruler:hover {
            background: #001100;
        }

        body.high-contrast .case-sensitive-btn.active,
        body.high-contrast .line-toggle.active,
        body.high-contrast .line-toggle-ruler.active {
            background: #003300;
        }

        /* ===========================
           RESET & BASE STYLES
           =========================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ===========================
           LAYOUT CONTAINER
           =========================== */
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
        }

        /* ===========================
           HEADER / MAIN TOOLBAR
           =========================== */
        header {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            padding: 12px 20px;
            border-bottom: 3px solid var(--accent-primary);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 200;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
            white-space: nowrap;
        }

        .file-type-indicator {
            font-size: 10px;
            color: var(--bg-primary);
            background: var(--accent-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 700;
            margin-left: auto;
            margin-right: 8px;
            white-space: nowrap;
            display: none;
        }

        .file-type-indicator.visible {
            display: inline-block;
        }

        .file-name {
            font-size: 13px;
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 500;
            margin-left: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .file-name.loaded {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Light mode: ensure filename is visible */
        body.light-mode .file-name.loaded {
            color: #333333;
            background: #e0e0e0;
        }

        .upload-btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .upload-btn:hover {
            background: #d63851;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .upload-btn:active {
            transform: translateY(0);
        }

        /* Search Container */
        .search-container {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-primary);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            flex: 1;
            max-width: 400px;
        }

        .search-icon {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .search-container input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 13px;
            padding: 4px 6px;
            outline: none;
            flex: 1;
            min-width: 100px;
        }

        .match-info {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
            display: none;
        }

        .match-info.visible {
            display: block;
        }

        .search-nav-btn,
        .clear-search-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            transition: color 0.2s ease;
        }

        .search-nav-btn:hover,
        .clear-search-btn:hover {
            color: var(--accent-primary);
        }

        .clear-search-btn {
            font-size: 18px;
            font-weight: bold;
            display: none;
        }

        .clear-search-btn.visible {
            display: block;
        }

        /* Case Sensitive Button */
        .case-sensitive-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            font-family: monospace;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .case-sensitive-btn:hover {
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .case-sensitive-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Zoom Dropdown in Toolbar */
        .zoom-dropdown-toolbar {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            min-width: 70px;
        }

        .zoom-dropdown-toolbar:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Settings Button */
        .settings-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 18px;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .settings-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 320px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 190;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .settings-panel.active {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-header h3 {
            margin: 0;
            font-size: 16px;
            color: var(--text-primary);
        }

        .settings-header .close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 24px;
            transition: color 0.2s ease;
        }

        .settings-header .close-btn:hover {
            color: var(--accent-primary);
        }

        .settings-content {
            padding: 16px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .settings-select {
            width: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }

        .theme-options,
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-option,
        .checkbox-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
        }

        .radio-option input,
        .checkbox-option input {
            cursor: pointer;
        }

        .zebra-colors {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            padding-left: 24px;
            align-items: center;
        }

        .zebra-colors label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .reset-colors-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reset-colors-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .tool-btn {
            display: block;
            width: 100%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 10px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .tool-btn:last-child {
            margin-bottom: 0;
        }

        .tool-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* ===========================
           ENHANCED RULER BAR
           =========================== */
        .ruler-bar {
            background: var(--bg-secondary);
            padding: 0;
            border-bottom: 1px solid var(--border-color);
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 150;
            display: flex;
            align-items: flex-end;
            min-height: 50px;
        }

        body.maximized header,
        body.maximized footer {
            display: none;
        }

        body.maximized .ruler-bar {
            top: 0;
        }

        body.maximized .report-container {
            padding-top: 80px;
            min-height: 100vh;
            margin: 0;
        }

        body.maximized .report-display {
            border-radius: 0;
            border: none;
        }

        body.maximized .ruler {
            top: 42px;
        }

        .ruler-content {
            position: relative;
            font-family: 'Courier New', Courier, monospace;
            font-size: var(--report-font-size, 11px);
            padding: 4px 20px 0 30px;
            white-space: nowrap;
            transform-origin: left top;
            flex: 1;
            line-height: 1.4;
        }

        .ruler-numbers {
            color: var(--accent-primary);
            font-weight: bold;
            white-space: pre;
        }

        .ruler-ticks {
            color: var(--text-secondary);
            white-space: pre;
        }

        /* Column highlight toggle button - positioned left of line toggle */
        .column-toggle-ruler {
            margin: 0 4px 4px 10px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            flex-shrink: 0;
            align-self: flex-end;
        }

        .column-toggle-ruler:hover,
        .column-toggle-ruler.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Line toggle button - positioned left of ruler ticks */
        .line-toggle-ruler {
            margin: 0 8px 4px 0;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            flex-shrink: 0;
            align-self: flex-end;
        }

        /* Cursor position indicator - positioned on right side of ruler */
        .ruler-cursor-position {
            margin: 0 20px 4px 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 2px 10px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
            align-self: flex-end;
        }

        .line-toggle-ruler:hover,
        .line-toggle-ruler.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .width-dropdown:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.active-indicator {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
            position: relative;
        }

        .btn.active-indicator::after {
            content: '‚óè';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 16px;
            color: #2ecc71;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        input[type="text"],
        input[type="number"],
        select {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.2);
        }

        input[type="color"] {
            width: 36px;
            height: 28px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .search-box {
            width: 250px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent-primary);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* ===========================
           REPORT DISPLAY AREA
           =========================== */
        .report-container {
            padding: 68px 30px 20px;
            min-height: calc(100vh - 250px);
        }

        .report-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: var(--report-font-size, 11px);
            white-space: pre;
            overflow-x: auto;
            background: var(--report-bg);
            color: var(--report-text);
            padding: 0;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            border-left: 35px solid var(--bg-secondary);
            position: relative;
            user-select: text;
            cursor: text;
        }

        /* Custom text selection colors */
        .report-display ::selection {
            background: #4a9eff;
            color: #ffffff;
        }

        .report-display ::-moz-selection {
            background: #4a9eff;
            color: #ffffff;
        }

        /* Light mode selection */
        body.light-mode .report-display ::selection {
            background: #0066cc;
            color: #ffffff;
        }

        body.light-mode .report-display ::-moz-selection {
            background: #0066cc;
            color: #ffffff;
        }

        /* High contrast selection */
        body.high-contrast .report-display ::selection {
            background: #00ff00;
            color: #000000;
        }

        body.high-contrast .report-display ::-moz-selection {
            background: #00ff00;
            color: #000000;
        }

        /* Light mode styles moved to theme variables
           Old .report-display.light-mode styles removed */

        .report-content {
            padding: 20px 20px 20px 7px;
            position: relative;
            user-select: text;
            overflow: visible;
        }

        /* Light mode zebra defaults */
        body.light-mode .zebra-even {
            background-color: #f5f5f5;
        }

        body.light-mode .zebra-odd {
            background-color: #ffffff;
        }

        .ruler {
            position: fixed;
            top: 105px;
            left: 0;
            right: 0;
            width: 100%;
            z-index: 10;
            font-family: 'Courier New', Courier, monospace;
            font-size: var(--report-font-size, 11px);
            background: var(--bg-tertiary);
            color: var(--ruler-text);
            padding: 14px 56px 3px;
            white-space: pre;
            overflow-x: hidden;
            border-bottom: 2px solid var(--accent-primary);
            user-select: none;
            pointer-events: none;
            transition: padding-left 0.2s ease;
        }

        .ruler > * {
            position: relative;
        }

        .ruler-content {
            flex: 1;
        }

        .cursor-position {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-primary);
            color: #ffffff;
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: auto;
        }

        .cursor-position.visible {
            opacity: 1;
        }

        .ruler.with-line-numbers {
            padding-left: 124px;  /* 60px width + 10px padding + 1px border + 10px margin + 20px base padding + 23px alignment adjustment */
        }

        .report-content {
            padding: 20px;
            position: relative;
        }

        .report-page {
            white-space: pre;
            position: relative;
            user-select: text;
        }

        /* Watermark overlay using pseudo-element */
        .report-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--watermark-image, none);
            background-repeat: no-repeat;
            background-position: var(--watermark-position, left top);
            background-size: var(--watermark-size, auto);
            pointer-events: none;
            z-index: 2;
        }

        .report-line {
            padding: 2px 5px;
            transition: background-color 0.2s ease;
            position: relative;
            z-index: 0;
            cursor: text;
            min-height: 1.2em;
            line-height: 1.2;
        }

        .line-number {
            position: absolute;
            left: -4.2em;
            width: 3.8em;
            color: var(--text-secondary);
            text-align: right;
            padding-right: 0.2em;
            user-select: none;
            font-size: 0.9em;
            cursor: default;
            overflow: visible;
        }

        .line-content {
            display: inline;
            white-space: pre;
            user-select: text;
            cursor: text;
        }

        /* Column highlight indicator */
        .column-highlight {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 1ch;
            background-color: rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .column-highlight.visible {
            display: block;
        }

        /* Cursor indicator */
        .cursor-indicator {
            position: absolute;
            width: 2px;
            height: 1.2em;
            background-color: red;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        .cursor-indicator.visible {
            display: block;
        }

        .report-line.zebra-even {
            background-color: var(--zebra-color1);
        }

        .report-line.zebra-odd {
            background-color: var(--zebra-color2);
        }

        .page-separator {
            margin: 20px 0;
            text-align: left;
            position: relative;
            padding-left: 20px;
            user-select: none;
            cursor: default;
        }

        .page-label {
            display: inline-block;
            background: var(--bg-secondary);
            color: var(--accent-primary);
            padding: 5px 15px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 5px;
        }

        .separator-line {
            border: none;
            border-top: 2px solid var(--accent-primary);
            margin: 5px 0 15px 0;
            opacity: 0.3;
        }

        /* ===========================
           SEARCH HIGHLIGHTING
           =========================== */
        .search-highlight {
            background-color: var(--highlight-color);
            color: #000;
            padding: 1px 2px;
            border-radius: 2px;
        }

        .search-highlight.current {
            background-color: #ff6b6b;
            color: white;
            font-weight: bold;
        }

        /* ===========================
           MODALS
           =========================== */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: var(--accent-primary);
            color: white;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* ===========================
           WATERMARK CONFIGURATION
           =========================== */
        .watermark-config {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .config-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-group label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .position-btn {
            padding: 15px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
            color: var(--text-primary);
        }

        .position-btn:hover {
            border-color: var(--accent-primary);
        }

        .position-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .slider-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-control input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
        }

        .slider-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
        }

        .slider-value {
            min-width: 50px;
            text-align: right;
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .watermark-preview {
            background: var(--report-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .watermark-preview img {
            max-width: 100%;
            max-height: 100%;
            opacity: 0.3;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upload-area:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .upload-area.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        /* ===========================
           PAGE RANGE TABLE
           =========================== */
        .ranges-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .ranges-table th,
        .ranges-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .ranges-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .ranges-table td {
            font-size: 13px;
        }

        .ranges-table tr:hover {
            background: var(--bg-tertiary);
        }

        .range-input {
            width: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        /* ===========================
           FOOTER
           =========================== */
        footer {
            background: var(--bg-secondary);
            padding: 15px 30px;
            border-top: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .footer-info {
            display: flex;
            gap: 30px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .footer-info span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .footer-info strong {
            color: var(--accent-primary);
        }

        /* ===========================
           PROGRESS INDICATOR
           =========================== */
        .progress-overlay {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .progress-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .progress-content {
            background: var(--bg-secondary);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .progress-title {
            font-size: 18px;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), #ff8fa3);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* ===========================
           TOAST NOTIFICATIONS
           =========================== */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-left: 4px solid var(--accent-primary);
            z-index: 3000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        .toast.active {
            display: block;
        }

        .toast.error {
            border-left-color: #e74c3c;
        }

        .toast.success {
            border-left-color: #2ecc71;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* ===========================
           EMPTY STATE
           =========================== */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .empty-state-subtext {
            font-size: 14px;
            opacity: 0.7;
        }

        /* ===========================
           RESPONSIVE DESIGN
           =========================== */
        @media (max-width: 1024px) {
            .toolbar-title {
                font-size: 16px;
            }

            .search-container {
                max-width: 300px;
            }
        }

        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 10px;
            }

            .toolbar-title {
                display: none;
            }

            .search-container {
                order: 3;
                width: 100%;
                max-width: none;
            }

            .file-name {
                order: 2;
                max-width: 150px;
            }

            .settings-panel {
                right: 10px;
                left: 10px;
                width: auto;
            }

            .ruler-bar {
                top: 85px;
            }

            .ruler {
                top: 125px;
            }

            .position-indicator {
                font-size: 11px;
                min-width: 70px;
            }

            .watermark-config {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            header {
                padding: 8px 12px;
            }

            .upload-btn {
                font-size: 12px;
                padding: 6px 12px;
            }

            .ruler-bar {
                padding: 6px 12px;
                gap: 8px;
            }

            .position-indicator {
                display: none;
            }
        }

        /* ===========================
           PRINT STYLES
           =========================== */
        @media print {
            body {
                background: white;
                color: black;
            }

            header,
            .control-panel,
            footer,
            .modal,
            .toast {
                display: none !important;
            }

            .report-display {
                border: none;
                padding: 0;
            }

            .page-separator {
                page-break-after: always;
            }
        }

        /* ===========================
           DRAG AND DROP FILE UPLOAD
           =========================== */
        .drop-zone {
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            background: var(--bg-tertiary);
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 20px 0;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.6;
        }

        .drop-zone-text {
            font-size: 16px;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .drop-zone-subtext {
            font-size: 13px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <!-- Main Toolbar (Single Row) -->
    <header>
        <div class="toolbar">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                üìÅ Open File
            </button>
            <input type="file" id="fileInput" accept=".txt,.TXT" style="display: none;" onchange="handleFileSelect(event)">

            <h1 class="toolbar-title">üìÑ Report/Spoolfile Viewer</h1>

            <div class="search-container">
                <span class="search-icon">üîç</span>
                <input type="text" id="searchBox" placeholder="Search..." onkeyup="handleSearchInput(event)">
                <span class="match-info" id="matchInfo"></span>
                <button class="search-nav-btn" onclick="previousSearchResult()" title="Previous match">‚óÑ</button>
                <button class="search-nav-btn" onclick="nextSearchResult()" title="Next match">‚ñ∫</button>
                <button class="clear-search-btn" id="clearSearchBtn" onclick="clearSearch()" title="Clear search">√ó</button>
            </div>

            <button class="case-sensitive-btn" id="caseSensitiveBtn" onclick="toggleCaseSensitive()" title="Case sensitive search">Aa</button>

            <select id="zoomDropdown" class="zoom-dropdown-toolbar" onchange="setZoomLevel(this.value)">
                <option value="50">50%</option>
                <option value="75">75%</option>
                <option value="100">100%</option>
                <option value="125">125%</option>
                <option value="150">150%</option>
                <option value="200">200%</option>
                <option value="fit" selected>Fit Width</option>
            </select>

            <select id="widthSelect" class="zoom-dropdown-toolbar" onchange="changeWidth()">
                <option value="auto" selected>Auto 132</option>
                <option value="80">80</option>
                <option value="132">132</option>
                <option value="160">160</option>
                <option value="198">198</option>
                <option value="255">255</option>
            </select>

            <button class="settings-btn" onclick="toggleSettingsPanel()" title="Settings">‚öôÔ∏è</button>

            <span class="file-type-indicator" id="fileTypeIndicator" title="File format type"></span>
            <span class="file-name" id="fileName">No file loaded</span>
        </div>
    </header>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="settings-panel">
        <div class="settings-header">
            <h3>‚öôÔ∏è Settings</h3>
            <button class="close-btn" onclick="toggleSettingsPanel()">‚úï</button>
        </div>

        <div class="settings-content">
            <!-- Theme Section -->
            <div class="settings-section">
                <label class="settings-label">Theme</label>
                <div class="theme-options">
                    <label class="radio-option">
                        <input type="radio" name="theme" value="light" onchange="setTheme('light')">
                        <span>Light</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="theme" value="dark" checked onchange="setTheme('dark')">
                        <span>Dark</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="theme" value="high-contrast" onchange="setTheme('high-contrast')">
                        <span>High Contrast</span>
                    </label>
                </div>
            </div>

            <!-- Display Section -->
            <div class="settings-section">
                <label class="settings-label">Display</label>
                <label class="checkbox-option">
                    <input type="checkbox" id="zebraToggle" onchange="toggleZebra()">
                    <span>Zebra striping</span>
                </label>
                <div class="zebra-colors" id="zebraColorControls" style="display: none;">
                    <label>Even <input type="color" id="zebraColor1" value="#1a1a2e" onchange="updateZebraColors()"></label>
                    <label>Odd <input type="color" id="zebraColor2" value="#0f3460" onchange="updateZebraColors()"></label>
                    <button class="reset-colors-btn" onclick="resetZebraColors()" title="Reset to default colors">Reset</button>
                </div>
            </div>

            <!-- Page Mode Section -->
            <div class="settings-section">
                <label class="settings-label">Page Mode</label>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="pageMode" value="dynamic" checked onchange="changePageMode()">
                        <span>Dynamic</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="pageMode" value="66" onchange="changePageMode()">
                        <span>Fixed 66</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="pageMode" value="88" onchange="changePageMode()">
                        <span>Fixed 88</span>
                    </label>
                </div>
            </div>

            <!-- Tools Section -->
            <div class="settings-section">
                <label class="settings-label">Tools</label>
                <button class="tool-btn" onclick="openWatermarkModal(); toggleSettingsPanel();">üé® Watermark...</button>
                <button class="tool-btn" onclick="openRangesModal(); toggleSettingsPanel();" id="rangesBtn">üìä Ranges...</button>
                <button class="tool-btn" onclick="exportToPDF(); toggleSettingsPanel();">üìÑ Export PDF</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Ruler Bar -->
    <div class="ruler-bar">
        <button class="column-toggle-ruler active" id="columnToggleBtn" onclick="toggleColumnHighlight()" title="Toggle column highlight">|</button>
        <button class="line-toggle-ruler" id="lineToggleBtn" onclick="toggleLineNumbers()" title="Toggle line numbers">#</button>
        <div class="ruler-content" id="stickyRulerContent">
            <!-- Ruler content will be generated here -->
        </div>
        <div class="ruler-cursor-position" id="rulerCursorPosition">Ln 1 Col 1</div>
    </div>

    <!-- Report Display -->
    <div class="report-container">
        <div id="reportDisplay" class="report-display">
            <div class="empty-state">
                <div class="empty-state-icon">üìÑ</div>
                <div class="empty-state-text">No report loaded</div>
                <div class="empty-state-subtext">Click "Open File" or drag & drop a .TXT file to begin</div>
            </div>
        </div>
    </div>

    <!-- Column highlight indicator -->
    <div id="columnHighlight" class="column-highlight"></div>

    <!-- Footer -->
    <footer>
        <div class="footer-info">
            <span><strong>Page:</strong> <span id="currentPage">-</span> of <span id="totalPages">-</span></span>
            <span><strong>Lines:</strong> <span id="totalLines">-</span></span>
            <span><strong>File Size:</strong> <span id="fileSize">-</span></span>
        </div>
        <div class="footer-info">
            <span>Keyboard: Ctrl+O (Open) | Ctrl+F (Search) | Ctrl+G (Jump) | Ctrl+E (Export) | Ctrl+/- (Zoom) | F3 (Next) | Ctrl+M/F11 (Maximize)</span>
        </div>
    </footer>

    <!-- Watermark Configuration Modal -->
    <div id="watermarkModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">üíß Watermark Configuration</h2>
                <button class="close-btn" onclick="closeWatermarkModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="watermark-config">
                    <div class="config-section">
                        <div class="config-group">
                            <label>Upload Watermark Image</label>
                            <div class="upload-area" id="watermarkUploadArea" onclick="document.getElementById('watermarkInput').click()">
                                <div style="font-size: 36px; margin-bottom: 10px;">üñºÔ∏è</div>
                                <div>Click to upload or drag & drop</div>
                                <div style="font-size: 12px; margin-top: 5px; color: var(--text-secondary);">PNG, JPG, SVG (max 5MB)</div>
                            </div>
                            <input type="file" id="watermarkInput" accept="image/*" style="display: none;" onchange="handleWatermarkUpload(event)">
                        </div>

                        <div class="config-group">
                            <label>Position</label>
                            <div class="position-grid">
                                <button class="position-btn" data-position="top-left" onclick="setWatermarkPosition('top-left')">Top Left</button>
                                <button class="position-btn" data-position="top-center" onclick="setWatermarkPosition('top-center')">Top Center</button>
                                <button class="position-btn" data-position="top-right" onclick="setWatermarkPosition('top-right')">Top Right</button>
                                <button class="position-btn" data-position="middle-left" onclick="setWatermarkPosition('middle-left')">Middle Left</button>
                                <button class="position-btn active" data-position="center" onclick="setWatermarkPosition('center')">Center</button>
                                <button class="position-btn" data-position="middle-right" onclick="setWatermarkPosition('middle-right')">Middle Right</button>
                                <button class="position-btn" data-position="bottom-left" onclick="setWatermarkPosition('bottom-left')">Bottom Left</button>
                                <button class="position-btn" data-position="bottom-center" onclick="setWatermarkPosition('bottom-center')">Bottom Center</button>
                                <button class="position-btn" data-position="bottom-right" onclick="setWatermarkPosition('bottom-right')">Bottom Right</button>
                            </div>
                        </div>

                        <div class="config-group">
                            <label>Rotation: <span id="rotationValue">0¬∞</span></label>
                            <div class="slider-control">
                                <input type="range" id="rotationSlider" min="-180" max="180" value="0" oninput="updateRotation(this.value)">
                            </div>
                        </div>

                        <div class="config-group">
                            <label>Opacity: <span id="opacityValue">30%</span></label>
                            <div class="slider-control">
                                <input type="range" id="opacitySlider" min="0" max="100" value="30" oninput="updateOpacity(this.value)">
                            </div>
                        </div>

                        <div class="config-group">
                            <label>Scale: <span id="scaleValue">1.0x</span></label>
                            <div class="slider-control">
                                <input type="range" id="scaleSlider" min="50" max="200" value="100" oninput="updateScale(this.value)">
                            </div>
                        </div>

                        <div class="config-group">
                            <label>
                                <input type="checkbox" id="watermarkEnabled" onchange="toggleWatermark()"> Enable Watermark
                            </label>
                        </div>
                    </div>

                    <div class="config-section">
                        <div class="config-group">
                            <label>Preview</label>
                            <div class="watermark-preview" id="watermarkPreview">
                                <div style="color: var(--text-secondary); text-align: center;">
                                    <div style="font-size: 48px; margin-bottom: 10px;">üñºÔ∏è</div>
                                    <div>Upload an image to preview</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeWatermarkModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Page Ranges Modal -->
    <div id="rangesModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">üìë Page Ranges</h2>
                <button class="close-btn" onclick="closeRangesModal()">&times;</button>
            </div>
            <div class="modal-body">
                <table class="ranges-table">
                    <thead>
                        <tr>
                            <th>Section Name</th>
                            <th>Start Page</th>
                            <th>Page Count</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="rangesTableBody">
                        <!-- Ranges will be added here dynamically -->
                    </tbody>
                </table>
                <button class="btn" onclick="addNewRange()">+ Add Range</button>
                <label style="margin-left: 20px;">
                    <input type="checkbox" id="showRangesOnly" onchange="toggleRangesFilter()"> Show Ranges Only
                </label>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeRangesModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Progress Overlay -->
    <div id="progressOverlay" class="progress-overlay">
        <div class="progress-content">
            <div class="progress-title" id="progressTitle">Processing...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">0%</div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- CDN Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- Main Application Script -->
    <script>
        // ===========================
        // STATE MANAGEMENT
        // ===========================
        const AppState = {
            // File data
            rawContent: null,
            lines: [],
            pages: [],
            fileName: '',
            fileSize: 0,
            fileType: 'Plain', // 'Channel', 'FormFeed', or 'Plain'

            // View settings
            zebraEnabled: false,
            zebraColor1: '#1a1a2e',
            zebraColor2: '#0f3460',
            zoomLevel: 'fit',
            showLineNumbers: true,
            showRuler: true, // Always true in new design
            columnHighlightEnabled: true, // Column highlight on hover
            theme: 'dark',

            // Page settings
            pageLengthMode: 'dynamic',
            fixedPageLength: 66,
            detectedWidth: 132,

            // Page ranges
            pageRanges: [],
            showRangesOnly: false,

            // Search
            searchTerm: '',
            searchResults: [],
            currentSearchIndex: -1,
            searchDebounceTimer: null,

            // Watermark
            watermark: {
                enabled: false,
                imageData: null,
                imageSrc: null,
                position: 'center',
                rotation: 0,
                opacity: 30,
                scale: 100
            },

            // UI state
            currentPage: 1,
            settingsPanelOpen: false
        };

        // ===========================
        // INITIALIZATION
        // ===========================
        window.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            setupDragAndDrop();
            setupKeyboardShortcuts();
            applyZebraColors();
            setupRulerSync();
        });

        function setupRulerSync() {
            // Ruler stays fixed at top - content scrolls underneath
            // No scroll sync needed
        }

        // Load saved settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('reportViewerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    if (settings.zebraColor1) AppState.zebraColor1 = settings.zebraColor1;
                    if (settings.zebraColor2) AppState.zebraColor2 = settings.zebraColor2;
                    if (settings.zebraEnabled !== undefined) AppState.zebraEnabled = settings.zebraEnabled;
                    if (settings.theme) AppState.theme = settings.theme;

                    document.getElementById('zebraColor1').value = AppState.zebraColor1;
                    document.getElementById('zebraColor2').value = AppState.zebraColor2;
                    document.getElementById('zebraToggle').checked = AppState.zebraEnabled;

                    // Apply theme
                    setTheme(AppState.theme);

                    // Show/hide zebra colors
                    if (AppState.zebraEnabled) {
                        document.getElementById('zebraColorControls').style.display = 'flex';
                    }

                    applyZebraColors();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                zebraColor1: AppState.zebraColor1,
                zebraColor2: AppState.zebraColor2,
                zebraEnabled: AppState.zebraEnabled,
                theme: AppState.theme
            };
            localStorage.setItem('reportViewerSettings', JSON.stringify(settings));
        }

        // ===========================
        // UI CONTROLS
        // ===========================

        // Toggle Settings Panel
        function toggleSettingsPanel() {
            const panel = document.getElementById('settingsPanel');
            AppState.settingsPanelOpen = !AppState.settingsPanelOpen;

            if (AppState.settingsPanelOpen) {
                panel.classList.add('active');
            } else {
                panel.classList.remove('active');
            }
        }

        // Close settings panel when clicking outside
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('settingsPanel');
            const settingsBtn = document.querySelector('.settings-btn');

            if (AppState.settingsPanelOpen &&
                !panel.contains(event.target) &&
                !settingsBtn.contains(event.target)) {
                toggleSettingsPanel();
            }
        });

        // Set Theme
        function setTheme(theme) {
            AppState.theme = theme;

            // Remove all theme classes
            document.body.classList.remove('light-mode', 'high-contrast');

            // Apply theme
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            } else if (theme === 'high-contrast') {
                document.body.classList.add('high-contrast');
            }

            // Update radio buttons
            document.querySelectorAll('input[name="theme"]').forEach(radio => {
                radio.checked = (radio.value === theme);
            });

            saveSettings();
        }

        // Set Zoom Level
        function setZoomLevel(value) {
            if (value === 'fit') {
                // Fit to width logic - calculate zoom to fit report width to viewport
                const reportDisplay = document.getElementById('reportDisplay');
                if (reportDisplay && AppState.detectedWidth > 0) {
                    const viewportWidth = reportDisplay.clientWidth;
                    const charWidth = 6.6; // Approximate width of a character at 11px (100% zoom)
                    const contentPadding = 40; // Left + right padding
                    const lineNumberWidth = AppState.showLineNumbers ? 81 : 0;

                    // Calculate required width for the report
                    const requiredWidth = (AppState.detectedWidth * charWidth) + contentPadding + lineNumberWidth;

                    // Calculate zoom percentage
                    let fitZoom = Math.floor((viewportWidth / requiredWidth) * 100);

                    // Clamp between 50% and 200%
                    fitZoom = Math.max(50, Math.min(200, fitZoom));

                    AppState.zoomLevel = fitZoom;

                    // Calculate font size
                    const fontSize = Math.round(11 * (fitZoom / 100)) + 'px';
                    document.documentElement.style.setProperty('--report-font-size', fontSize);

                    showToast(`Zoom set to ${fitZoom}% (Fit Width)`, 'success');
                } else {
                    AppState.zoomLevel = 100;
                    document.documentElement.style.setProperty('--report-font-size', '11px');
                }
            } else {
                AppState.zoomLevel = parseInt(value);

                const fontSizeMap = {
                    50: '5.5px',
                    75: '8px',
                    100: '11px',
                    125: '14px',
                    150: '16px',
                    200: '22px'
                };

                const fontSize = fontSizeMap[AppState.zoomLevel] || '11px';
                document.documentElement.style.setProperty('--report-font-size', fontSize);
            }

            // Ruler now uses variable font-size, so no scaleX needed
            // Just ensure padding stays consistent (CSS handles it)

            // Update dropdown
            document.getElementById('zoomDropdown').value = value;
        }

        // Handle Search Input with Debouncing
        function handleSearchInput(event) {
            const searchBox = document.getElementById('searchBox');
            const clearBtn = document.getElementById('clearSearchBtn');

            // Handle Escape key
            if (event.key === 'Escape') {
                clearSearch();
                return;
            }

            // Show/hide clear button
            if (searchBox.value.length > 0) {
                clearBtn.classList.add('visible');
            } else {
                clearBtn.classList.remove('visible');
            }

            // Debounce search
            if (AppState.searchDebounceTimer) {
                clearTimeout(AppState.searchDebounceTimer);
            }

            AppState.searchDebounceTimer = setTimeout(() => {
                if (event.key === 'Enter') {
                    performSearch();
                } else if (searchBox.value.length >= 2) {
                    performSearch();
                }
            }, 300);
        }

        // Update search results display
        function updateSearchDisplay() {
            const matchInfo = document.getElementById('matchInfo');

            if (AppState.searchResults.length > 0) {
                const currentIndex = AppState.currentSearchIndex + 1;
                matchInfo.textContent = `${currentIndex}/${AppState.searchResults.length}`;
                matchInfo.classList.add('visible');
            } else if (AppState.searchTerm && AppState.searchResults.length === 0) {
                matchInfo.textContent = '0/0';
                matchInfo.classList.add('visible');
            } else {
                matchInfo.classList.remove('visible');
            }
        }

        // Updated Toggle Zebra to show/hide color controls
        function toggleZebra() {
            AppState.zebraEnabled = document.getElementById('zebraToggle').checked;
            const colorControls = document.getElementById('zebraColorControls');

            if (AppState.zebraEnabled) {
                colorControls.style.display = 'flex';
            } else {
                colorControls.style.display = 'none';
            }

            applyZebraColors();
            saveSettings();
        }

        // Updated Change Page Mode for radio buttons
        function changePageMode() {
            const selectedMode = document.querySelector('input[name="pageMode"]:checked').value;

            if (selectedMode === 'dynamic') {
                AppState.pageLengthMode = 'dynamic';
            } else {
                AppState.pageLengthMode = parseInt(selectedMode);
                AppState.fixedPageLength = parseInt(selectedMode);
            }

            if (AppState.lines.length > 0) {
                detectPages();
                renderReport();
            }
        }

        // Updated Toggle Line Numbers
        function toggleLineNumbers() {
            AppState.showLineNumbers = !AppState.showLineNumbers;
            const toggleBtn = document.getElementById('lineToggleBtn');

            if (AppState.showLineNumbers) {
                toggleBtn.classList.add('active');
            } else {
                toggleBtn.classList.remove('active');
            }

            renderReport();
        }

        // Toggle Column Highlight
        function toggleColumnHighlight() {
            AppState.columnHighlightEnabled = !AppState.columnHighlightEnabled;
            const toggleBtn = document.getElementById('columnToggleBtn');

            if (AppState.columnHighlightEnabled) {
                toggleBtn.classList.add('active');
            } else {
                toggleBtn.classList.remove('active');
                // Hide the highlight when disabled
                const columnHighlight = document.getElementById('columnHighlight');
                if (columnHighlight) {
                    columnHighlight.classList.remove('visible');
                }
            }
        }

        // Update Position Indicator
        function updatePositionIndicator(line, col) {
            const indicator = document.getElementById('positionIndicator');
            indicator.textContent = `Ln ${line} Col ${col}`;
        }

        // Toggle Case Sensitive Search
        function toggleCaseSensitive() {
            const btn = document.getElementById('caseSensitiveBtn');
            const isActive = btn.classList.toggle('active');

            // If search is already active, re-run it with new case sensitivity
            if (AppState.searchTerm && AppState.lines.length > 0) {
                performSearch();
            }
        }

        // Check if case sensitive is active
        function isCaseSensitive() {
            const btn = document.getElementById('caseSensitiveBtn');
            return btn && btn.classList.contains('active');
        }

        // ===========================
        // FILE HANDLING
        // ===========================
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadFile(file);
            }
        }

        function loadFile(file) {
            showProgress('Loading file...', 0);

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    AppState.rawContent = e.target.result;
                    AppState.fileName = file.name;
                    AppState.fileSize = file.size;

                    // Clear page ranges when loading a new file
                    AppState.pageRanges = [];
                    AppState.showRangesOnly = false;

                    // Update the checkbox UI
                    const rangesCheckbox = document.getElementById('showRangesOnly');
                    if (rangesCheckbox) {
                        rangesCheckbox.checked = false;
                    }

                    updateProgress(30, 'Parsing content...');

                    // Use setTimeout to allow UI to update
                    setTimeout(() => {
                        parseReportFile();
                        updateProgress(60, 'Detecting pages...');

                        setTimeout(() => {
                            detectPages();
                            detectReportWidth();
                            updateProgress(80, 'Rendering display...');

                            setTimeout(() => {
                                renderReport();
                                updateFileInfo();

                                // Apply Fit Width zoom by default
                                setZoomLevel('fit');
                                document.getElementById('zoomDropdown').value = 'fit';

                                updateProgress(100, 'Complete!');

                                setTimeout(() => {
                                    hideProgress();
                                    showToast(`File loaded! Width: ${AppState.detectedWidth} columns`, 'success');
                                }, 500);
                            }, 100);
                        }, 100);
                    }, 100);
                } catch (error) {
                    hideProgress();
                    showToast('Error loading file: ' + error.message, 'error');
                    console.error('File load error:', error);
                }
            };

            reader.onerror = function() {
                hideProgress();
                showToast('Error reading file', 'error');
            };

            reader.readAsText(file);
        }

        // ===========================
        // FILE PARSING
        // ===========================
        function parseReportFile() {
            const lines = AppState.rawContent.split(/\r?\n/);
            AppState.lines = [];
            let currentPage = 1;

            // First check if file contains FormFeed characters (ASCII 12 or \f)
            // If it does, it's an ASCII report with FormFeeds, not ASA carriage control
            const hasFormFeeds = AppState.rawContent.includes('\f') ||
                                 /\x0C/.test(AppState.rawContent);

            // Detect if file uses ASA carriage control (first char of every line is control)
            // Only check for ASA format if there are NO FormFeed characters
            let usesASACarriageControl = false;
            if (!hasFormFeeds) {
                // Check first non-comment, non-empty lines
                let asaIndicatorCount = 0;
                let checkedLines = 0;
                for (let i = 0; i < Math.min(20, lines.length) && checkedLines < 10; i++) {
                    // Skip JES2 comments and empty lines
                    if (lines[i].startsWith('*$') || lines[i].length === 0) continue;

                    checkedLines++;
                    const firstChar = lines[i].charAt(0);
                    // ASA control characters: 1 (new page), 0 (double space), - (single space), space (normal), + (overprint)
                    if (firstChar === '1' || firstChar === '0' || firstChar === '-' || firstChar === ' ' || firstChar === '+') {
                        asaIndicatorCount++;
                    }
                }
                // If more than 70% of checked lines have ASA control characters, assume ASA format
                if (checkedLines > 0 && asaIndicatorCount / checkedLines > 0.7) {
                    usesASACarriageControl = true;
                }
            }

            // Store file type in AppState
            AppState.fileType = hasFormFeeds ? 'FormFeed' : (usesASACarriageControl ? 'Channel' : 'Plain');

            lines.forEach((rawLine, index) => {
                // Skip JES2 spool commands (lines starting with *$)
                if (rawLine.startsWith('*$')) {
                    return;
                }

                if (rawLine.length === 0) {
                    // Empty line
                    const lineObj = {
                        lineNumber: index + 1,
                        rawText: rawLine,
                        displayText: '',
                        controlChar: '',
                        pageNumber: currentPage,
                        isPageBreak: false,
                        hasMatch: false
                    };
                    AppState.lines.push(lineObj);
                    return;
                }

                const controlChar = rawLine.charAt(0);
                let displayText = rawLine;
                let isPageBreak = false;

                // Check for form feed character (ASCII 12)
                const isFormFeed = controlChar === '\f' || controlChar.charCodeAt(0) === 12;

                if (isFormFeed) {
                    // Form feed - always a page break, strip it
                    displayText = rawLine.substring(1);
                    isPageBreak = true;
                } else if (usesASACarriageControl) {
                    // ASA carriage control format - first char is always control
                    // Strip control char and the space that typically follows it
                    if (controlChar === '1') {
                        // Strip control char, and also strip following space if present
                        displayText = rawLine.substring(1);
                        if (displayText.charAt(0) === ' ') {
                            displayText = displayText.substring(1);
                        }
                        isPageBreak = true;
                    } else if (controlChar === '0' || controlChar === '-' || controlChar === ' ' || controlChar === '+') {
                        // Other carriage control chars (0=double space, -=single space, +=overprint, space=normal)
                        // Strip control char, and also strip following space if present
                        displayText = rawLine.substring(1);
                        if (displayText.charAt(0) === ' ') {
                            displayText = displayText.substring(1);
                        }
                    }
                } else {
                    // No carriage control - keep line as-is unless it's a form feed
                    displayText = rawLine;
                }

                const lineObj = {
                    lineNumber: index + 1,
                    rawText: rawLine,
                    displayText: displayText,
                    controlChar: controlChar,
                    pageNumber: currentPage,
                    isPageBreak: isPageBreak,
                    hasMatch: false
                };

                // If this is a page break (and not the first line), increment page
                if (isPageBreak && index > 0) {
                    currentPage++;
                    lineObj.pageNumber = currentPage;
                }

                AppState.lines.push(lineObj);
            });
        }

        // ===========================
        // PAGE DETECTION
        // ===========================
        function detectPages() {
            AppState.pages = [];

            if (AppState.pageLengthMode === 'dynamic') {
                detectPagesDynamic();
            } else {
                detectPagesFixed();
            }
        }

        function detectPagesDynamic() {
            let currentPage = {
                pageNumber: 1,
                startLineNumber: 1,
                lines: [],
                hasSearchMatch: false
            };

            AppState.lines.forEach((line, index) => {
                if (line.isPageBreak && index > 0) {
                    // Finalize current page
                    currentPage.endLineNumber = AppState.lines[index - 1].lineNumber;
                    currentPage.lineCount = currentPage.lines.length;
                    AppState.pages.push(currentPage);

                    // Start new page
                    currentPage = {
                        pageNumber: currentPage.pageNumber + 1,
                        startLineNumber: line.lineNumber,
                        lines: [],
                        hasSearchMatch: false
                    };
                }

                line.pageNumber = currentPage.pageNumber;
                currentPage.lines.push(line);
            });

            // Add final page
            if (currentPage.lines.length > 0) {
                currentPage.endLineNumber = AppState.lines[AppState.lines.length - 1].lineNumber;
                currentPage.lineCount = currentPage.lines.length;
                AppState.pages.push(currentPage);
            }
        }

        function detectPagesFixed() {
            const linesPerPage = parseInt(AppState.fixedPageLength);
            let pageNumber = 1;

            for (let i = 0; i < AppState.lines.length; i += linesPerPage) {
                const pageLines = AppState.lines.slice(i, i + linesPerPage);

                pageLines.forEach(line => {
                    line.pageNumber = pageNumber;
                });

                const page = {
                    pageNumber: pageNumber,
                    startLineNumber: pageLines[0].lineNumber,
                    endLineNumber: pageLines[pageLines.length - 1].lineNumber,
                    lineCount: pageLines.length,
                    lines: pageLines,
                    hasSearchMatch: false
                };

                AppState.pages.push(page);
                pageNumber++;
            }
        }

        // ===========================
        // RENDERING
        // ===========================
        function renderReport() {
            const display = document.getElementById('reportDisplay');

            // Determine which pages to display
            let pagesToDisplay = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                pagesToDisplay = filterPagesByRanges();
            }

            // Build report content efficiently
            let html = '<div class="report-content">';

            pagesToDisplay.forEach((page, pageIndex) => {
                // Add page separator
                const sectionName = getSectionNameForPage(page.pageNumber);
                const pageLabelText = sectionName
                    ? `‚îÄ‚îÄ PAGE ${page.pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                    : `‚îÄ‚îÄ PAGE ${page.pageNumber} ‚îÄ‚îÄ`;
                html += `<div class="page-separator" data-page="${page.pageNumber}">`;
                html += `<div><span class="page-label">${pageLabelText}</span></div>`;
                html += `<hr class="separator-line"></div>`;

                // Create page container
                html += `<div class="report-page" data-page="${page.pageNumber}" id="page-${page.pageNumber}">`;

                // Add all lines for this page
                page.lines.forEach((line, lineIndex) => {
                    const zebraClass = AppState.zebraEnabled ? (lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd') : '';
                    html += `<div class="report-line ${zebraClass}" data-line="${line.lineNumber}" data-page="${page.pageNumber}" data-page-line="${lineIndex + 1}">`;
                    if (AppState.showLineNumbers) {
                        html += `<span class="line-number">${lineIndex + 1}</span>`;
                    }
                    html += `<span class="line-content">${escapeHtml(line.displayText)}</span>`;
                    html += `</div>`;
                });

                html += '</div>';
            });

            html += '</div>';
            display.innerHTML = html;

            // Apply watermark if enabled (use setTimeout to ensure DOM is ready)
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                console.log('Scheduling watermark application in 100ms...');
                setTimeout(() => {
                    console.log('Timeout fired - calling applyWatermarkToDisplay');
                    applyWatermarkToDisplay();
                }, 100);
            } else {
                console.log('Watermark NOT scheduled - enabled:', AppState.watermark.enabled, 'imageSrc:', !!AppState.watermark.imageSrc);
            }

            // Update page jump input (disabled in new design)
            // const pageJumpEl = document.getElementById('pageJump');
            // if (pageJumpEl) pageJumpEl.max = pagesToDisplay.length;

            // Update ranges button indicator
            updateRangesIndicator();

            // Update sticky ruler bar
            updateStickyRuler();
        }

        function buildRuler() {
            if (!AppState.showRuler) {
                return '';
            }

            const width = AppState.detectedWidth;
            let numbers = '';
            let ticks = '';

            for (let i = 1; i <= width; i++) {
                if (i % 10 === 0) {
                    // Show the full number (10, 20, 30, etc.)
                    const num = String(i);
                    // Back up and place the digits
                    const padding = num.length - 1;
                    // We need to place the digits backwards from this position
                    numbers += num.charAt(num.length - 1);
                    ticks += '|';
                } else if (i % 5 === 0) {
                    numbers += ' ';
                    ticks += '+';
                } else {
                    numbers += ' ';
                    ticks += '.';
                }
            }

            // Now build the proper number line
            let numberLine = '';
            for (let i = 1; i <= width; i++) {
                if (i % 10 === 0) {
                    const num = String(i);
                    // Place the number right-aligned at this position
                    const start = i - num.length;
                    for (let j = 0; j < num.length; j++) {
                        const pos = start + j;
                        if (pos >= 0 && pos < numberLine.length) {
                            numberLine = numberLine.substring(0, pos) + num[j] + numberLine.substring(pos + 1);
                        }
                    }
                } else {
                    if (numberLine.length < i) {
                        numberLine += ' ';
                    }
                }
            }

            // Rebuild properly
            numberLine = '';
            for (let i = 1; i <= width; i++) {
                let placed = false;

                // Check if this position is part of a decade number
                for (let decade = 10; decade <= width; decade += 10) {
                    const numStr = String(decade);
                    const startPos = decade - numStr.length + 1;
                    const endPos = decade;

                    if (i >= startPos && i <= endPos) {
                        const digitIndex = i - startPos;
                        numberLine += numStr[digitIndex];
                        placed = true;
                        break;
                    }
                }

                if (!placed) {
                    numberLine += ' ';
                }
            }

            return `<div class="ruler-numbers">${numberLine}</div><div class="ruler-ticks">${ticks}</div>`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateStickyRuler() {
            const stickyRulerContent = document.getElementById('stickyRulerContent');
            const lineToggleBtn = document.getElementById('lineToggleBtn');

            if (stickyRulerContent) {
                const rulerHTML = buildRuler();
                stickyRulerContent.innerHTML = rulerHTML;
            }

            // Update line toggle button state
            if (lineToggleBtn) {
                if (AppState.showLineNumbers) {
                    lineToggleBtn.classList.add('active');
                } else {
                    lineToggleBtn.classList.remove('active');
                }
            }
        }

        function updateFileInfo() {
            document.getElementById('fileName').textContent = AppState.fileName;
            document.getElementById('fileName').classList.add('loaded');
            document.getElementById('totalPages').textContent = AppState.pages.length;
            document.getElementById('totalLines').textContent = AppState.lines.length;
            document.getElementById('fileSize').textContent = formatFileSize(AppState.fileSize);
            document.getElementById('currentPage').textContent = '1';

            // Update file type indicator
            const fileTypeIndicator = document.getElementById('fileTypeIndicator');
            if (AppState.fileType && AppState.fileType !== 'Plain') {
                fileTypeIndicator.textContent = AppState.fileType === 'Channel' ? 'CH' : 'FF';
                fileTypeIndicator.title = AppState.fileType === 'Channel' ? 'Channel Code Format' : 'Form Feed Format';
                fileTypeIndicator.classList.add('visible');
            } else {
                fileTypeIndicator.classList.remove('visible');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // ===========================
        // ZEBRA STRIPING
        // ===========================
        // Old toggleZebra function removed - using updated version that shows/hides color controls

        function updateZebraColors() {
            AppState.zebraColor1 = document.getElementById('zebraColor1').value;
            AppState.zebraColor2 = document.getElementById('zebraColor2').value;
            applyZebraColors();
            if (AppState.zebraEnabled) {
                applyZebraPattern();
            }
            saveSettings();
        }

        function applyZebraColors() {
            document.documentElement.style.setProperty('--zebra-color1', AppState.zebraColor1);
            document.documentElement.style.setProperty('--zebra-color2', AppState.zebraColor2);
        }

        function resetZebraColors() {
            AppState.zebraColor1 = '#1a1a2e';
            AppState.zebraColor2 = '#0f3460';
            document.getElementById('zebraColor1').value = AppState.zebraColor1;
            document.getElementById('zebraColor2').value = AppState.zebraColor2;
            applyZebraColors();
            if (AppState.zebraEnabled) {
                applyZebraPattern();
            }
            saveSettings();
        }

        function applyZebraPattern() {
            // Re-render to apply zebra pattern
            if (AppState.searchTerm) {
                renderReportWithSearch();
            } else {
                renderReport();
            }
        }

        // ===========================
        // MAXIMIZE/MINIMIZE VIEW
        // ===========================
        function toggleMaximize() {
            const body = document.body;
            const maximizeIcon = document.getElementById('maximizeIcon');
            const reportDisplay = document.getElementById('reportDisplay');

            if (body.classList.contains('maximized')) {
                body.classList.remove('maximized');
                maximizeIcon.textContent = '‚õ∂ Maximize';
            } else {
                body.classList.add('maximized');
                maximizeIcon.textContent = '‚õ∂ Minimize';
                // Scroll to top when maximizing to avoid empty space
                if (reportDisplay) {
                    reportDisplay.scrollTop = 0;
                }
            }
        }

        // ===========================
        // PAGE MODE
        // ===========================
        // Old changePageMode function removed - using updated version with radio buttons

        // ===========================
        // VIEW TOGGLES
        // ===========================
        // Ruler is always shown in the new design
        // toggleRuler function removed

        // Old toggleLineNumbers function removed - using updated version with # button

        // Light mode replaced with setTheme() function
        // toggleLightMode function removed

        function changeWidth() {
            const widthSelect = document.getElementById('widthSelect');
            const value = widthSelect.value;

            if (value === 'auto') {
                // Auto-detect width
                detectReportWidth();
                // Update dropdown text to show detected width
                const autoOption = widthSelect.querySelector('option[value="auto"]');
                if (autoOption) {
                    autoOption.textContent = `Auto ${AppState.detectedWidth}`;
                }
            } else {
                AppState.detectedWidth = parseInt(value);
            }

            if (AppState.lines.length > 0) {
                if (AppState.searchTerm) {
                    renderReportWithSearch();
                } else {
                    renderReport();
                }
            }
        }

        function detectReportWidth() {
            let maxWidth = 132; // Default
            let actualMaxWidth = 0;

            AppState.lines.forEach(line => {
                const lineLength = line.displayText.length;
                if (lineLength > actualMaxWidth) {
                    actualMaxWidth = lineLength;
                }
            });

            maxWidth = actualMaxWidth;

            // Round up to nearest standard width
            if (maxWidth <= 80) {
                AppState.detectedWidth = 80;
            } else if (maxWidth <= 132) {
                AppState.detectedWidth = 132;
            } else if (maxWidth <= 198) {
                AppState.detectedWidth = 198;
            } else {
                AppState.detectedWidth = 255;
            }

            // Update select to show detected width if auto
            const widthSelect = document.getElementById('widthSelect');
            if (widthSelect && widthSelect.value === 'auto') {
                const autoOption = widthSelect.querySelector('option[value="auto"]');
                if (autoOption) {
                    autoOption.textContent = `‚ñº Auto ${AppState.detectedWidth}`;
                }
            }
        }

        function updateRangesIndicator() {
            const btn = document.getElementById('rangesBtn');
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                btn.classList.add('active-indicator');
                btn.title = `Filter active: ${AppState.pageRanges.length} range(s)`;
            } else {
                btn.classList.remove('active-indicator');
                btn.title = 'Define page ranges';
            }
        }

        // ===========================
        // SEARCH FUNCTIONALITY
        // ===========================
        // handleSearchKeyup replaced with handleSearchInput (with debouncing)
        // Old handleSearchKeyup function removed

        function performSearch() {
            const term = document.getElementById('searchBox').value.trim();
            if (!term || AppState.lines.length === 0) {
                updateSearchDisplay();
                return;
            }

            const caseSensitive = isCaseSensitive();
            AppState.searchTerm = term;
            AppState.searchResults = [];
            AppState.currentSearchIndex = -1;

            // Clear previous matches
            AppState.lines.forEach(line => line.hasMatch = false);

            // Escape special regex characters
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');

            // Find all matches
            AppState.lines.forEach((line, index) => {
                let match;
                const testRegex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');
                while ((match = testRegex.exec(line.displayText)) !== null) {
                    AppState.searchResults.push({
                        lineIndex: index,
                        lineNumber: line.lineNumber,
                        pageNumber: line.pageNumber,
                        matchStart: match.index,
                        matchLength: term.length
                    });
                    line.hasMatch = true;
                }
            });

            // Update UI
            updateSearchDisplay();
            if (AppState.searchResults.length > 0) {
                renderReportWithSearch();
                jumpToSearchResult(0);
            } else {
                showToast('No matches found', 'error');
            }
        }

        function highlightSearchResults() {
            // Re-render with search highlights
            renderReportWithSearch();
        }

        function renderReportWithSearch() {
            const display = document.getElementById('reportDisplay');

            // Determine which pages to display
            let pagesToDisplay = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                pagesToDisplay = filterPagesByRanges();
            }

            const caseSensitive = isCaseSensitive();
            const escapedTerm = AppState.searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Build report content with search highlights
            let html = '<div class="report-content">';

            pagesToDisplay.forEach((page, pageIndex) => {
                // Add page separator
                const sectionName = getSectionNameForPage(page.pageNumber);
                const pageLabelText = sectionName
                    ? `‚îÄ‚îÄ PAGE ${page.pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                    : `‚îÄ‚îÄ PAGE ${page.pageNumber} ‚îÄ‚îÄ`;
                html += `<div class="page-separator" data-page="${page.pageNumber}">`;
                html += `<div><span class="page-label">${pageLabelText}</span></div>`;
                html += `<hr class="separator-line"></div>`;

                // Create page container
                html += `<div class="report-page" data-page="${page.pageNumber}" id="page-${page.pageNumber}">`;

                // Add all lines for this page
                page.lines.forEach((line, lineIndex) => {
                    let lineText = escapeHtml(line.displayText);

                    // Apply search highlighting if this line has a match
                    if (line.hasMatch && AppState.searchTerm) {
                        // Create new regex for each line to avoid lastIndex issues
                        const regex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');
                        lineText = lineText.replace(regex, '<span class="search-highlight">$&</span>');
                    }

                    const zebraClass = AppState.zebraEnabled ? (lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd') : '';
                    html += `<div class="report-line ${zebraClass}" data-line="${line.lineNumber}">`;
                    if (AppState.showLineNumbers) {
                        html += `<span class="line-number">${line.lineNumber}</span>`;
                    }
                    html += `<span class="line-content">${lineText}</span>`;
                    html += `</div>`;
                });

                html += '</div>';
            });

            html += '</div>';
            display.innerHTML = html;

            // Apply watermark if enabled (use setTimeout to ensure DOM is ready)
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                console.log('Scheduling watermark application in 100ms...');
                setTimeout(() => {
                    console.log('Timeout fired - calling applyWatermarkToDisplay');
                    applyWatermarkToDisplay();
                }, 100);
            } else {
                console.log('Watermark NOT scheduled - enabled:', AppState.watermark.enabled, 'imageSrc:', !!AppState.watermark.imageSrc);
            }

            // Update ranges button indicator
            updateRangesIndicator();

            // Update sticky ruler bar
            updateStickyRuler();
        }

        function jumpToSearchResult(index) {
            if (AppState.searchResults.length === 0) return;

            AppState.currentSearchIndex = index;
            const result = AppState.searchResults[index];

            // Update current highlight
            const highlights = document.querySelectorAll('.search-highlight');
            highlights.forEach(h => h.classList.remove('current'));

            // Find and highlight current result
            const lineElement = document.querySelector(`[data-line="${result.lineNumber}"]`);
            if (lineElement) {
                const highlight = lineElement.querySelectorAll('.search-highlight')[0];
                if (highlight) {
                    highlight.classList.add('current');
                }
                lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Update search display
            updateSearchDisplay();
        }

        function nextSearchResult() {
            if (AppState.searchResults.length === 0) return;
            const nextIndex = (AppState.currentSearchIndex + 1) % AppState.searchResults.length;
            jumpToSearchResult(nextIndex);
        }

        function previousSearchResult() {
            if (AppState.searchResults.length === 0) return;
            const prevIndex = (AppState.currentSearchIndex - 1 + AppState.searchResults.length) % AppState.searchResults.length;
            jumpToSearchResult(prevIndex);
        }

        function clearSearch() {
            document.getElementById('searchBox').value = '';
            document.getElementById('clearSearchBtn').classList.remove('visible');
            AppState.searchTerm = '';
            AppState.searchResults = [];
            AppState.currentSearchIndex = -1;

            // Clear hasMatch flags
            AppState.lines.forEach(line => line.hasMatch = false);

            // Update display
            updateSearchDisplay();

            // Re-render without search highlights
            renderReport();
        }

        // ===========================
        // PAGE NAVIGATION
        // ===========================
        function handlePageJumpKeyup(event) {
            if (event.key === 'Enter') {
                jumpToPage();
            }
        }

        function jumpToPage() {
            const pageNum = parseInt(document.getElementById('pageJump').value);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > AppState.pages.length) {
                showToast('Invalid page number', 'error');
                return;
            }

            const separator = document.querySelector(`[data-page="${pageNum}"]`);
            if (separator) {
                separator.scrollIntoView({ behavior: 'smooth', block: 'start' });
                AppState.currentPage = pageNum;
                document.getElementById('currentPage').textContent = pageNum;
            }
        }

        // ===========================
        // PAGE RANGES
        // ===========================
        function openRangesModal() {
            if (AppState.pages.length === 0) {
                showToast('Please load a file first', 'error');
                return;
            }
            renderRangesTable();
            document.getElementById('showRangesOnly').checked = AppState.showRangesOnly;
            document.getElementById('rangesModal').classList.add('active');
        }

        function closeRangesModal() {
            document.getElementById('rangesModal').classList.remove('active');
        }

        function renderRangesTable() {
            const tbody = document.getElementById('rangesTableBody');
            tbody.innerHTML = '';

            if (AppState.pageRanges.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">No ranges defined</td></tr>';
                return;
            }

            AppState.pageRanges.forEach((range, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><input type="text" class="range-input" value="${range.name}" onchange="updateRangeName(${index}, this.value)"></td>
                    <td><input type="number" class="range-input" value="${range.startPage}" min="1" max="${AppState.pages.length}" onchange="updateRangeStart(${index}, this.value)"></td>
                    <td><input type="number" class="range-input" value="${range.pageCount}" min="1" onchange="updateRangeCount(${index}, this.value)"></td>
                    <td><button class="btn btn-small" onclick="deleteRange(${index})">Delete</button></td>
                `;
                tbody.appendChild(row);
            });
        }

        function addNewRange() {
            const newRange = {
                id: Date.now(),
                name: `Section ${AppState.pageRanges.length + 1}`,
                startPage: 1,
                pageCount: 1
            };
            AppState.pageRanges.push(newRange);
            renderRangesTable();
            if (AppState.showRangesOnly && AppState.lines.length > 0) {
                renderReport();
            }
            updateRangesIndicator();
        }

        function updateRangeName(index, name) {
            AppState.pageRanges[index].name = name;
            if (AppState.showRangesOnly && AppState.lines.length > 0) {
                renderReport();
            }
        }

        function updateRangeStart(index, value) {
            const startPage = parseInt(value);
            if (startPage >= 1 && startPage <= AppState.pages.length) {
                AppState.pageRanges[index].startPage = startPage;
                if (AppState.showRangesOnly && AppState.lines.length > 0) {
                    renderReport();
                }
            }
        }

        function updateRangeCount(index, value) {
            const count = parseInt(value);
            if (count >= 1) {
                AppState.pageRanges[index].pageCount = count;
                if (AppState.showRangesOnly && AppState.lines.length > 0) {
                    renderReport();
                }
            }
        }

        function deleteRange(index) {
            AppState.pageRanges.splice(index, 1);
            renderRangesTable();
            if (AppState.showRangesOnly && AppState.lines.length > 0) {
                renderReport();
            }
            updateRangesIndicator();
        }

        function toggleRangesFilter() {
            AppState.showRangesOnly = document.getElementById('showRangesOnly').checked;
            if (AppState.lines.length > 0) {
                renderReport();
                if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                    showToast('Showing selected ranges only', 'success');
                } else {
                    showToast('Showing all pages', 'success');
                }
            }
            updateRangesIndicator();
        }

        // ===========================
        // WATERMARK
        // ===========================
        function openWatermarkModal() {
            document.getElementById('watermarkModal').classList.add('active');
            setupWatermarkDragDrop();
            updateWatermarkPreview();
        }

        function closeWatermarkModal() {
            document.getElementById('watermarkModal').classList.remove('active');
            // Re-render if watermark settings changed
            if (AppState.lines.length > 0 && AppState.watermark.enabled) {
                if (AppState.searchTerm) {
                    renderReportWithSearch();
                } else {
                    renderReport();
                }
            }
        }

        function setupWatermarkDragDrop() {
            const uploadArea = document.getElementById('watermarkUploadArea');

            uploadArea.ondragover = (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            };

            uploadArea.ondragleave = () => {
                uploadArea.classList.remove('dragover');
            };

            uploadArea.ondrop = (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadWatermarkImage(file);
                }
            };
        }

        function handleWatermarkUpload(event) {
            const file = event.target.files[0];
            if (file) {
                loadWatermarkImage(file);
            }
        }

        function loadWatermarkImage(file) {
            if (file.size > 5 * 1024 * 1024) {
                showToast('Image too large (max 5MB)', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Scale down large images to fit page better
                    const maxDimension = 400; // Max width or height in pixels
                    let scaledImg = img;

                    if (img.width > maxDimension || img.height > maxDimension) {
                        // Create a scaled version
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        let scale = 1;
                        if (img.width > img.height) {
                            scale = maxDimension / img.width;
                        } else {
                            scale = maxDimension / img.height;
                        }

                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;

                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        // Create new image from scaled canvas
                        scaledImg = new Image();
                        scaledImg.onload = () => {
                            AppState.watermark.imageData = scaledImg;
                            AppState.watermark.imageSrc = canvas.toDataURL();
                            updateWatermarkPreview();
                            showToast(`Watermark loaded (scaled to ${Math.round(canvas.width)}x${Math.round(canvas.height)})`, 'success');
                        };
                        scaledImg.src = canvas.toDataURL();
                    } else {
                        AppState.watermark.imageData = img;
                        AppState.watermark.imageSrc = e.target.result;
                        updateWatermarkPreview();
                        showToast('Watermark image loaded', 'success');
                    }
                };
                img.onerror = () => {
                    showToast('Error loading image', 'error');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setWatermarkPosition(position) {
            AppState.watermark.position = position;

            // Update button styles
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-position="${position}"]`).classList.add('active');

            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateRotation(value) {
            AppState.watermark.rotation = parseInt(value);
            document.getElementById('rotationValue').textContent = value + '¬∞';
            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateOpacity(value) {
            AppState.watermark.opacity = parseInt(value);
            document.getElementById('opacityValue').textContent = value + '%';
            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateScale(value) {
            AppState.watermark.scale = parseInt(value);
            document.getElementById('scaleValue').textContent = (value / 100).toFixed(1) + 'x';
            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateLiveWatermark() {
            // Update watermark in real-time if enabled and content is loaded
            if (AppState.watermark.enabled && AppState.lines.length > 0 && AppState.watermark.imageData) {
                applyWatermarkToDisplay();
            }
        }

        function toggleWatermark() {
            AppState.watermark.enabled = document.getElementById('watermarkEnabled').checked;
            if (AppState.watermark.enabled && !AppState.watermark.imageData) {
                showToast('Please upload a watermark image first', 'error');
                document.getElementById('watermarkEnabled').checked = false;
                AppState.watermark.enabled = false;
                return;
            }
            if (AppState.lines.length > 0) {
                renderReport();
            }
        }

        function applyWatermarkToDisplay() {
            console.log('=== applyWatermarkToDisplay called ===');
            console.log('Watermark enabled:', AppState.watermark.enabled);
            console.log('Watermark imageSrc:', AppState.watermark.imageSrc ? 'exists' : 'null');
            console.log('Watermark imageData:', AppState.watermark.imageData);

            if (!AppState.watermark.enabled || !AppState.watermark.imageSrc) {
                console.log('Watermark not enabled or no image source - exiting');
                return;
            }

            if (!AppState.watermark.imageData) {
                console.error('Watermark imageData not loaded');
                return;
            }

            const opacity = AppState.watermark.opacity / 100;
            const scale = AppState.watermark.scale / 100;
            const rotation = AppState.watermark.rotation;

            console.log('Watermark settings:', { opacity, scale, rotation, position: AppState.watermark.position });

            // Apply to all page elements
            const pages = document.querySelectorAll('.report-page');

            console.log('Found pages:', pages.length);

            if (pages.length === 0) {
                console.warn('No report pages found for watermark application');
                return;
            }

            pages.forEach((pageEl, index) => {
                try {
                    console.log(`Processing page ${index + 1}`);

                    // Use actual page element dimensions for accurate positioning
                    const pageRect = pageEl.getBoundingClientRect();
                    const pageWidth = pageEl.offsetWidth;
                    const pageHeight = pageEl.offsetHeight;

                    console.log(`  Page dimensions: ${pageWidth}x${pageHeight}`);

                    // Count lines and calculate line-based positioning
                    const lineElements = pageEl.querySelectorAll('.report-line');
                    const lineCount = lineElements.length;
                    console.log(`  Line count: ${lineCount}`);

                    // Create watermark canvas sized to actual page
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = Math.max(pageWidth, 100);
                    canvas.height = Math.max(pageHeight, 400);

                // Calculate position within content area
                const positions = {
                    'top-left': { x: 0.15, y: 0.15 },
                    'top-center': { x: 0.5, y: 0.15 },
                    'top-right': { x: 0.85, y: 0.15 },
                    'middle-left': { x: 0.15, y: 0.5 },
                    'center': { x: 0.5, y: 0.5 },
                    'middle-right': { x: 0.85, y: 0.5 },
                    'bottom-left': { x: 0.15, y: 0.85 },
                    'bottom-center': { x: 0.5, y: 0.85 },
                    'bottom-right': { x: 0.85, y: 0.85 }
                };

                const pos = positions[AppState.watermark.position] || positions['center'];

                // For middle/center positions, calculate based on actual line positions
                let yPos = pos.y;
                if (lineCount > 0 && (AppState.watermark.position.includes('middle') || AppState.watermark.position === 'center')) {
                    const firstLine = lineElements[0];
                    const lastLine = lineElements[lineCount - 1];
                    if (firstLine && lastLine) {
                        const firstLineTop = firstLine.offsetTop;
                        const lastLineTop = lastLine.offsetTop;
                        const lastLineBottom = lastLineTop + lastLine.offsetHeight;

                        // Middle of content is between first line top and last line bottom
                        const contentMiddle = (firstLineTop + lastLineBottom) / 2;
                        yPos = contentMiddle / pageHeight;

                        console.log(`  Line-based center: firstLine=${firstLineTop}px, lastLine=${lastLineBottom}px, middle=${contentMiddle}px, ratio=${yPos.toFixed(3)}`);
                    }
                }

                const x = canvas.width * pos.x;
                const y = canvas.height * yPos;

                console.log(`  Position: ${AppState.watermark.position} at (${x}, ${y})`);

                // Draw watermark
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.translate(x, y);
                ctx.rotate(rotation * Math.PI / 180);

                const imgWidth = AppState.watermark.imageData.width * scale;
                const imgHeight = AppState.watermark.imageData.height * scale;

                console.log(`  Image size: ${imgWidth}x${imgHeight}`);

                ctx.drawImage(
                    AppState.watermark.imageData,
                    -imgWidth / 2,
                    -imgHeight / 2,
                    imgWidth,
                    imgHeight
                );
                ctx.restore();

                    // Apply watermark to page using CSS custom properties
                    const dataUrl = canvas.toDataURL();
                    console.log(`  Data URL length: ${dataUrl.length}`);

                    pageEl.style.setProperty('--watermark-image', `url(${dataUrl})`);
                    pageEl.style.setProperty('--watermark-position', 'left top');
                    pageEl.style.setProperty('--watermark-size', `${canvas.width}px ${canvas.height}px`);

                    console.log(`  Applied to page - CSS properties set`);
                } catch (error) {
                    console.error('Error applying watermark to page:', error);
                }
            });
            console.log('=== Watermark application complete ===');
        }

        function updateWatermarkPreview() {
            const preview = document.getElementById('watermarkPreview');

            if (!AppState.watermark.imageData) {
                preview.innerHTML = `
                    <div style="color: var(--text-secondary); text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">üñºÔ∏è</div>
                        <div>Upload an image to preview</div>
                    </div>
                `;
                return;
            }

            // Create preview with watermark
            preview.innerHTML = '';
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Use preview pane dimensions
            const previewWidth = preview.offsetWidth || 400;
            const previewHeight = preview.offsetHeight || 300;

            canvas.width = previewWidth;
            canvas.height = previewHeight;

            // Fill background to simulate report
            ctx.fillStyle = AppState.theme === 'light' ? '#ffffff' : (AppState.theme === 'high-contrast' ? '#000000' : '#0a0a0a');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sample text at readable size (don't scale down)
            ctx.fillStyle = AppState.theme === 'light' ? '#000000' : (AppState.theme === 'high-contrast' ? '#00ff00' : '#e0e0e0');
            ctx.font = '9px Courier New';
            const sampleLines = [
                'REPORT NO - SAMPLE          PREVIEW OF WATERMARK PLACEMENT',
                'ACCOUNT  NAME           AMOUNT      DATE       STATUS',
                '12345    JOHN DOE        1,234.56    01/27/26   ACTIVE',
                '67890    JANE SMITH      5,678.90    01/27/26   ACTIVE',
                '11111    BOB JOHNSON     9,012.34    01/27/26   PENDING',
                '22222    ALICE BROWN     3,456.78    01/27/26   ACTIVE'
            ];

            const lineHeight = 11;
            const startY = 20;
            for (let i = 0; i < sampleLines.length; i++) {
                ctx.fillText(sampleLines[i], 10, startY + i * lineHeight);
            }

            // Continue pattern
            for (let i = sampleLines.length; i < Math.floor((canvas.height - startY) / lineHeight); i++) {
                const lineIndex = i % sampleLines.length;
                ctx.fillText(sampleLines[lineIndex], 10, startY + i * lineHeight);
            }

            // Calculate position for watermark
            const positions = {
                'top-left': { x: 0.15, y: 0.15 },
                'top-center': { x: 0.5, y: 0.15 },
                'top-right': { x: 0.85, y: 0.15 },
                'middle-left': { x: 0.15, y: 0.5 },
                'center': { x: 0.5, y: 0.5 },
                'middle-right': { x: 0.85, y: 0.5 },
                'bottom-left': { x: 0.15, y: 0.85 },
                'bottom-center': { x: 0.5, y: 0.85 },
                'bottom-right': { x: 0.85, y: 0.85 }
            };

            const pos = positions[AppState.watermark.position] || positions['center'];
            const x = canvas.width * pos.x;
            const y = canvas.height * pos.y;

            // Draw watermark at preview scale
            ctx.save();
            ctx.globalAlpha = AppState.watermark.opacity / 100;
            ctx.translate(x, y);
            ctx.rotate(AppState.watermark.rotation * Math.PI / 180);

            const userScale = AppState.watermark.scale / 100;
            // Show watermark at a reasonable preview size (0.5x of actual for preview)
            const previewScale = 0.5;
            const imgWidth = AppState.watermark.imageData.width * userScale * previewScale;
            const imgHeight = AppState.watermark.imageData.height * userScale * previewScale;

            ctx.drawImage(
                AppState.watermark.imageData,
                -imgWidth / 2,
                -imgHeight / 2,
                imgWidth,
                imgHeight
            );
            ctx.restore();

            preview.appendChild(canvas);
        }

        // ===========================
        // PDF EXPORT
        // ===========================
        async function exportToPDF() {
            if (AppState.pages.length === 0) {
                showToast('Please load a file first', 'error');
                return;
            }

            // Check if libraries are loaded
            if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
                showToast('PDF libraries not loaded. Please refresh the page.', 'error');
                return;
            }

            try {
                showProgress('Preparing PDF export...', 0);

                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'in',
                    format: [11, 14.875]
                });

                // Determine which pages to export
                let pagesToExport = AppState.pages;
                if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                    pagesToExport = filterPagesByRanges();
                }

                const totalPages = pagesToExport.length;

                for (let i = 0; i < totalPages; i++) {
                    const page = pagesToExport[i];
                    updateProgress(((i + 1) / totalPages) * 100, `Exporting page ${i + 1} of ${totalPages}...`);

                    // Create temporary container for this page
                    const pageContainer = createPageElement(page);
                    document.body.appendChild(pageContainer);

                    // PDF always uses white background and black text (no zebra, no theme)
                    // Only apply watermark if enabled
                    if (AppState.watermark.enabled && AppState.watermark.imageData) {
                        await applyWatermarkToElement(pageContainer);
                    }

                    // Render to canvas - always use white background for PDF
                    const canvas = await html2canvas(pageContainer, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false,
                        useCORS: true
                    });

                    // Remove temporary container
                    document.body.removeChild(pageContainer);

                    // Add to PDF
                    const imgData = canvas.toDataURL('image/png');
                    if (i > 0) pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 0, 0, 14.875, 11, undefined, 'FAST');

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // Save PDF
                const fileName = `${AppState.fileName.replace('.txt', '').replace('.TXT', '')}_export_${Date.now()}.pdf`;
                pdf.save(fileName);

                hideProgress();
                showToast('PDF exported successfully!', 'success');
            } catch (error) {
                hideProgress();
                showToast('Error exporting PDF: ' + error.message, 'error');
                console.error('PDF export error:', error);
            }
        }

        function filterPagesByRanges() {
            const filteredPages = [];
            AppState.pageRanges.forEach(range => {
                for (let i = 0; i < range.pageCount; i++) {
                    const pageNum = range.startPage + i;
                    const page = AppState.pages.find(p => p.pageNumber === pageNum);
                    if (page) {
                        filteredPages.push(page);
                    }
                }
            });
            return filteredPages;
        }

        function getSectionNameForPage(pageNumber) {
            if (!AppState.showRangesOnly || AppState.pageRanges.length === 0) {
                return null;
            }

            for (const range of AppState.pageRanges) {
                const endPage = range.startPage + range.pageCount - 1;
                if (pageNumber >= range.startPage && pageNumber <= endPage) {
                    return range.name;
                }
            }
            return null;
        }

        function createPageElement(page) {
            const container = document.createElement('div');

            // Calculate fixed height based on standard page
            // 66 lines √ó 13px per line (11px font + 4px padding) = 858px + 40px padding = 898px
            const fixedHeight = 898;

            // For PDF, always use white background and black text (ignore theme and zebra)
            const bgColor = '#ffffff';
            const textColor = '#000000';

            container.style.cssText = `
                position: absolute;
                left: -9999px;
                top: 0;
                width: 1487px;
                height: ${fixedHeight}px;
                min-height: ${fixedHeight}px;
                padding: 20px;
                background: ${bgColor};
                font-family: 'Courier New', Courier, monospace;
                font-size: 11px;
                white-space: pre;
                color: ${textColor};
                overflow: hidden;
            `;

            page.lines.forEach((line, idx) => {
                const lineDiv = document.createElement('div');
                lineDiv.textContent = line.displayText;
                lineDiv.style.cssText = `
                    padding: 2px 5px;
                    line-height: 1.2;
                    color: ${textColor};
                `;
                container.appendChild(lineDiv);
            });

            return container;
        }

        function applyZebraToElement(element) {
            const lines = element.querySelectorAll('div');
            lines.forEach((line, idx) => {
                line.style.backgroundColor = (idx % 2 === 0) ? AppState.zebraColor1 : AppState.zebraColor2;
            });
        }

        async function applyWatermarkToElement(element) {
            // Create watermark overlay div
            const watermarkDiv = document.createElement('div');
            watermarkDiv.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
            `;

            // Create canvas for watermark
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = element.offsetWidth;
            canvas.height = element.offsetHeight;

            // Count lines and calculate line-based positioning
            const lineElements = element.querySelectorAll('div');
            const lineCount = lineElements.length;

            // Calculate position (same as display)
            const positions = {
                'top-left': { x: 0.15, y: 0.15 },
                'top-center': { x: 0.5, y: 0.15 },
                'top-right': { x: 0.85, y: 0.15 },
                'middle-left': { x: 0.15, y: 0.5 },
                'center': { x: 0.5, y: 0.5 },
                'middle-right': { x: 0.85, y: 0.5 },
                'bottom-left': { x: 0.15, y: 0.85 },
                'bottom-center': { x: 0.5, y: 0.85 },
                'bottom-right': { x: 0.85, y: 0.85 }
            };

            const pos = positions[AppState.watermark.position] || positions['center'];

            // For middle/center positions, calculate based on actual line positions
            let yPos = pos.y;
            if (lineCount > 0 && (AppState.watermark.position.includes('middle') || AppState.watermark.position === 'center')) {
                const firstLine = lineElements[0];
                const lastLine = lineElements[lineCount - 1];
                if (firstLine && lastLine) {
                    const firstLineTop = firstLine.offsetTop;
                    const lastLineTop = lastLine.offsetTop;
                    const lastLineBottom = lastLineTop + lastLine.offsetHeight;

                    // Middle of content is between first line top and last line bottom
                    const contentMiddle = (firstLineTop + lastLineBottom) / 2;
                    yPos = contentMiddle / canvas.height;
                }
            }

            const x = canvas.width * pos.x;
            const y = canvas.height * yPos;

            // Draw watermark
            ctx.save();
            ctx.globalAlpha = AppState.watermark.opacity / 100;
            ctx.translate(x, y);
            ctx.rotate(AppState.watermark.rotation * Math.PI / 180);

            const scale = AppState.watermark.scale / 100;
            const imgWidth = AppState.watermark.imageData.width * scale;
            const imgHeight = AppState.watermark.imageData.height * scale;

            ctx.drawImage(
                AppState.watermark.imageData,
                -imgWidth / 2,
                -imgHeight / 2,
                imgWidth,
                imgHeight
            );
            ctx.restore();

            // Apply canvas as background of overlay div
            watermarkDiv.style.backgroundImage = `url(${canvas.toDataURL()})`;
            watermarkDiv.style.backgroundRepeat = 'no-repeat';
            watermarkDiv.style.backgroundPosition = 'left top';
            watermarkDiv.style.backgroundSize = '100% 100%';

            // Make element position relative and append watermark
            element.style.position = 'relative';
            element.appendChild(watermarkDiv);
        }

        // ===========================
        // DRAG AND DROP
        // ===========================
        function setupDragAndDrop() {
            const dropZone = document.getElementById('reportDisplay');

            dropZone.ondragover = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            dropZone.ondrop = (e) => {
                e.preventDefault();
                e.stopPropagation();

                const file = e.dataTransfer.files[0];
                if (file && (file.name.endsWith('.txt') || file.name.endsWith('.TXT'))) {
                    loadFile(file);
                } else {
                    showToast('Please drop a .TXT file', 'error');
                }
            };
        }

        // ===========================
        // KEYBOARD SHORTCUTS
        // ===========================
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+O: Open file
                if (e.ctrlKey && e.key === 'o') {
                    e.preventDefault();
                    document.getElementById('fileInput').click();
                }

                // Ctrl+F: Focus search
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    document.getElementById('searchBox').focus();
                }

                // Ctrl+G: Jump to page (disabled in new design - no page jump UI)
                // if (e.ctrlKey && e.key === 'g') {
                //     e.preventDefault();
                //     // Page jump functionality not implemented in new toolbar design
                // }

                // Ctrl+E: Export PDF
                if (e.ctrlKey && e.key === 'e') {
                    e.preventDefault();
                    exportToPDF();
                }

                // Ctrl+W: Toggle watermark modal
                if (e.ctrlKey && e.key === 'w') {
                    e.preventDefault();
                    openWatermarkModal();
                }

                // Ctrl+Z: Toggle zebra
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    const toggle = document.getElementById('zebraToggle');
                    toggle.checked = !toggle.checked;
                    toggleZebra();
                }

                // Ctrl+ (Plus/Equal): Zoom in
                if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                    e.preventDefault();
                    const currentZoom = AppState.zoomLevel;
                    const zoomLevels = [50, 75, 100, 125, 150, 200];
                    const currentIndex = zoomLevels.indexOf(currentZoom);
                    if (currentIndex < zoomLevels.length - 1) {
                        setZoomLevel(zoomLevels[currentIndex + 1].toString());
                    }
                }

                // Ctrl- (Minus): Zoom out
                if (e.ctrlKey && e.key === '-') {
                    e.preventDefault();
                    const currentZoom = AppState.zoomLevel;
                    const zoomLevels = [50, 75, 100, 125, 150, 200];
                    const currentIndex = zoomLevels.indexOf(currentZoom);
                    if (currentIndex > 0) {
                        setZoomLevel(zoomLevels[currentIndex - 1].toString());
                    }
                }

                // Ctrl+0: Reset zoom
                if (e.ctrlKey && e.key === '0') {
                    e.preventDefault();
                    setZoomLevel('100');
                }

                // F3: Next search result
                if (e.key === 'F3') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        previousSearchResult();
                    } else {
                        nextSearchResult();
                    }
                }

                // Escape: Close modals
                if (e.key === 'Escape') {
                    closeWatermarkModal();
                    closeRangesModal();
                }

                // Ctrl+M: Toggle maximize
                if (e.ctrlKey && e.key === 'm') {
                    e.preventDefault();
                    toggleMaximize();
                }

                // F11: Toggle maximize (alternative)
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleMaximize();
                }
            });
        }

        // ===========================
        // PROGRESS INDICATOR
        // ===========================
        function showProgress(title, percent) {
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = Math.round(percent) + '%';
            document.getElementById('progressOverlay').classList.add('active');
        }

        function updateProgress(percent, title) {
            if (title) {
                document.getElementById('progressTitle').textContent = title;
            }
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = Math.round(percent) + '%';
        }

        function hideProgress() {
            document.getElementById('progressOverlay').classList.remove('active');
        }

        // ===========================
        // TOAST NOTIFICATIONS
        // ===========================
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} active`;

            setTimeout(() => {
                toast.classList.remove('active');
            }, 3000);
        }

        // ===========================
        // ZOOM FUNCTIONS
        // ===========================
        // Zoom functions replaced with setZoomLevel() dropdown
        // Old zoomIn, zoomOut, resetZoom, applyZoom functions removed

        // ===========================
        // UTILITY FUNCTIONS
        // ===========================

        // Scroll detection for current page indicator
        let scrollTimeout;
        document.getElementById('reportDisplay')?.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                updateCurrentPageIndicator();
            }, 100);
        });

        function updateCurrentPageIndicator() {
            const display = document.getElementById('reportDisplay');
            const scrollTop = display.scrollTop;
            const separators = document.querySelectorAll('.page-separator');

            let currentPage = 1;
            separators.forEach(sep => {
                if (sep.offsetTop <= scrollTop + 100) {
                    currentPage = parseInt(sep.getAttribute('data-page'));
                }
            });

            document.getElementById('currentPage').textContent = currentPage;
            AppState.currentPage = currentPage;
        }

        // ===========================
        // CURSOR POSITION TRACKING
        // ===========================
        function updateCursorPosition(row, col) {
            const indicator = document.getElementById('rulerCursorPosition');
            if (indicator) {
                indicator.textContent = `Ln ${row} Col ${col}`;
            }
        }

        function handleReportClick(event) {
            // Find the clicked line element
            let target = event.target;
            while (target && !target.classList.contains('report-line')) {
                target = target.parentElement;
                if (target === document.getElementById('reportDisplay')) {
                    return; // Clicked outside a line
                }
            }

            if (!target) return;

            // Get the page-relative line number
            const pageLineNum = parseInt(target.getAttribute('data-page-line')) || 1;

            // Calculate column position
            const lineContent = target.querySelector('.line-content');
            if (!lineContent) return;

            // Get click position relative to line content
            const rect = lineContent.getBoundingClientRect();
            const clickX = event.clientX - rect.left;

            // Calculate character width (monospace font)
            const fontSize = parseFloat(getComputedStyle(lineContent).fontSize) || 11;
            const charWidth = fontSize * 0.6; // Courier New character width approximation

            // Calculate column (1-based)
            const col = Math.max(1, Math.min(AppState.detectedWidth, Math.floor(clickX / charWidth) + 1));

            updateCursorPosition(pageLineNum, col);
        }

        // Handle mouse move for column highlighting
        function handleReportMouseMove(event) {
            const reportDisplay = document.getElementById('reportDisplay');
            const columnHighlight = document.getElementById('columnHighlight');

            if (!reportDisplay || !columnHighlight) return;

            // Find the line under the mouse
            const lineElements = reportDisplay.querySelectorAll('.report-line');
            let hoveredLine = null;
            let pageLineNum = 1;

            for (const lineEl of lineElements) {
                const lineRect = lineEl.getBoundingClientRect();
                if (event.clientY >= lineRect.top && event.clientY <= lineRect.bottom) {
                    hoveredLine = lineEl;
                    pageLineNum = parseInt(lineEl.getAttribute('data-page-line')) || 1;
                    break;
                }
            }

            if (!hoveredLine) {
                columnHighlight.classList.remove('visible');
                return;
            }

            // Calculate character width based on current zoom
            const fontSize = parseFloat(getComputedStyle(reportDisplay).fontSize);
            const charWidth = fontSize * 0.6; // Approximate monospace character width

            // Get the line content span (where actual text starts)
            const lineContent = hoveredLine.querySelector('.line-content');
            if (!lineContent) return;

            const lineContentRect = lineContent.getBoundingClientRect();
            const mouseXRelativeToText = event.clientX - lineContentRect.left;

            // Calculate column (1-based, accounting for text starting position)
            const col = Math.max(1, Math.floor(mouseXRelativeToText / charWidth) + 1);

            // Update cursor position indicator on hover
            updateCursorPosition(pageLineNum, col);

            // Only show column highlight if enabled and mouse is over text
            if (AppState.columnHighlightEnabled && mouseXRelativeToText >= 0) {
                const highlightLeft = lineContentRect.left + (Math.floor(mouseXRelativeToText / charWidth) * charWidth);
                columnHighlight.style.left = highlightLeft + 'px';
                columnHighlight.style.width = charWidth + 'px';
                columnHighlight.classList.add('visible');
            } else {
                columnHighlight.classList.remove('visible');
            }
        }

        // Handle mouse leave to hide column highlight and reset position
        function handleReportMouseLeave() {
            const columnHighlight = document.getElementById('columnHighlight');
            if (columnHighlight) {
                columnHighlight.classList.remove('visible');
            }
            // Reset cursor position indicator
            updateCursorPosition(1, 1);
        }

        // Add click and mouse event listeners to report display
        function setupCursorTracking() {
            const reportDisplay = document.getElementById('reportDisplay');
            if (reportDisplay && !reportDisplay.dataset.cursorTrackingEnabled) {
                reportDisplay.addEventListener('click', handleReportClick);
                reportDisplay.addEventListener('mousemove', handleReportMouseMove);
                reportDisplay.addEventListener('mouseleave', handleReportMouseLeave);
                reportDisplay.dataset.cursorTrackingEnabled = 'true';
            }
        }

        // Set up tracking when DOM is loaded
        document.addEventListener('DOMContentLoaded', setupCursorTracking);
        // Also call it immediately in case DOM is already loaded
        setupCursorTracking();

    </script>
</body>
</html>
