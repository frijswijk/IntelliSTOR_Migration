<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report/Spoolfile Viewer</title>
    <style>
        /* ===========================
           CSS VARIABLES (THEMING)
           =========================== */
        /* Dark theme (default) */
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --accent-primary: #e94560;
            --text-primary: #e0e0e0;
            --text-secondary: #b8b8b8;
            --report-bg: #0a0a0a;
            --report-text: #e0e0e0;
            --border-color: #0f3460;
            --highlight-color: #f1c40f;
            --highlight-bg: #ffff00;
            --highlight-text: #000;
            --zebra-color1: #1a1a2e;
            --zebra-color2: #0f3460;
            --ruler-text: #888;
        }

        /* Light theme */
        body.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e0e0e0;
            --accent-primary: #d63447;
            --text-primary: #333333;
            --text-secondary: #666666;
            --report-bg: #ffffff;
            --report-text: #333333;
            --border-color: #cccccc;
            --highlight-color: #f39c12;
            --highlight-bg: #ffff00;
            --highlight-text: #000;
            --ruler-text: #666;
        }

        /* High Contrast theme - "Green Screen" terminal style */
        body.high-contrast {
            --bg-primary: #000000;
            --bg-secondary: #000000;
            --bg-tertiary: #001100;
            --accent-primary: #00ff00;
            --text-primary: #00ff00;
            --text-secondary: #00ff00;
            --report-bg: #000000;
            --report-text: #00ff00;
            --border-color: #00ff00;
            --highlight-color: #00ff00;
            --highlight-bg: #ffffff;
            --highlight-text: #000000;
            --ruler-text: #00ff00;
        }

        body.high-contrast .report-display {
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 2px var(--report-text);
        }

        body.high-contrast .ruler .decade-marker {
            color: #00ffff;
            font-weight: bold;
        }

        body.high-contrast .search-highlight {
            background: #ffff00;
            color: #000000;
            outline: 2px solid #ffffff;
        }

        /* High contrast button styling - green outline with black background */
        body.high-contrast .upload-btn,
        body.high-contrast .settings-btn,
        body.high-contrast .case-sensitive-btn,
        body.high-contrast .line-toggle,
        body.high-contrast .line-toggle-ruler {
            background: #000000;
            color: #00ff00;
            border: 2px solid #00ff00;
        }

        body.high-contrast .upload-btn:hover,
        body.high-contrast .settings-btn:hover,
        body.high-contrast .case-sensitive-btn:hover,
        body.high-contrast .line-toggle:hover,
        body.high-contrast .line-toggle-ruler:hover {
            background: #001100;
        }

        body.high-contrast .case-sensitive-btn.active,
        body.high-contrast .line-toggle.active,
        body.high-contrast .line-toggle-ruler.active {
            background: #003300;
        }

        /* ===========================
           RESET & BASE STYLES
           =========================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ===========================
           LAYOUT CONTAINER
           =========================== */
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
        }

        /* ===========================
           HEADER / MAIN TOOLBAR
           =========================== */
        header {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            padding: 12px 20px;
            border-bottom: 3px solid var(--accent-primary);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 200;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
            white-space: nowrap;
        }

        .file-type-indicator {
            font-size: 10px;
            color: var(--bg-primary);
            background: var(--accent-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 700;
            margin-left: auto;
            margin-right: 8px;
            white-space: nowrap;
            display: none;
        }

        .file-type-indicator.visible {
            display: inline-block;
        }

        .file-name {
            font-size: 13px;
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 500;
            margin-left: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .file-name.loaded {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Light mode: ensure filename is visible */
        body.light-mode .file-name.loaded {
            color: #333333;
            background: #e0e0e0;
        }

        .upload-btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .upload-btn:hover {
            background: #d63851;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .upload-btn:active {
            transform: translateY(0);
        }

        /* Search Container */
        .search-container {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-primary);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            flex: 1;
            max-width: 400px;
        }

        .search-icon {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .search-container input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 13px;
            padding: 4px 6px;
            outline: none;
            flex: 1;
            min-width: 100px;
        }

        /* Page jump container - fixed compact width */
        #pageJumpContainer {
            flex: 0 0 110px !important;
            width: 110px !important;
            min-width: 110px !important;
            max-width: 110px !important;
        }

        /* Page jump input should NOT flex - fixed width */
        #pageJumpInput {
            flex: 0 0 38px !important;
            min-width: 38px !important;
            width: 38px !important;
            max-width: 38px !important;
        }

        /* Hide number input spinner arrows */
        #pageJumpInput::-webkit-inner-spin-button,
        #pageJumpInput::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #pageJumpInput[type=number] {
            -moz-appearance: textfield;
        }

        .match-info {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
            display: none;
        }

        .match-info.visible {
            display: block;
        }

        .search-nav-btn,
        .clear-search-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            transition: color 0.2s ease;
        }

        .search-nav-btn:hover,
        .clear-search-btn:hover {
            color: var(--accent-primary);
        }

        .clear-search-btn {
            font-size: 18px;
            font-weight: bold;
            display: none;
        }

        .clear-search-btn.visible {
            display: block;
        }

        /* Case Sensitive Button */
        .case-sensitive-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            font-family: monospace;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .case-sensitive-btn:hover {
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .case-sensitive-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Zoom Dropdown in Toolbar */
        .zoom-dropdown-toolbar {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            min-width: 70px;
        }

        .zoom-dropdown-toolbar:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Settings Button */
        .settings-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 18px;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .settings-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        /* Search Results Panel */
        .search-results-panel {
            position: fixed;
            top: 120px;
            right: 20px;
            width: 280px;
            max-height: calc(100vh - 180px);
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 195;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .search-results-panel.active {
            display: flex;
            flex-direction: column;
        }

        .search-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .search-results-header h4 {
            margin: 0;
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .search-results-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            line-height: 20px;
            transition: color 0.2s ease;
        }

        .search-results-close:hover {
            color: var(--accent-primary);
        }

        .search-results-content {
            overflow-y: auto;
            padding: 8px;
            flex: 1;
        }

        .search-result-page {
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-page:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .search-result-page-number {
            font-weight: 600;
            color: var(--accent-primary);
            font-size: 12px;
        }

        .search-result-match-count {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 320px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 190;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .settings-panel.active {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-header h3 {
            margin: 0;
            font-size: 16px;
            color: var(--text-primary);
        }

        .settings-header .close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 24px;
            transition: color 0.2s ease;
        }

        .settings-header .close-btn:hover {
            color: var(--accent-primary);
        }

        .settings-content {
            padding: 16px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .settings-select {
            width: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }

        .theme-options,
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-option,
        .checkbox-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
        }

        .radio-option input,
        .checkbox-option input {
            cursor: pointer;
        }

        .zebra-colors {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            padding-left: 24px;
            align-items: center;
        }

        .zebra-colors label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .reset-colors-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reset-colors-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .tool-btn {
            display: block;
            width: 100%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 10px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .tool-btn:last-child {
            margin-bottom: 0;
        }

        .tool-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* ===========================
           ENHANCED RULER BAR
           =========================== */
        .ruler-bar {
            background: var(--bg-secondary);
            padding: 0;
            border-bottom: 1px solid var(--border-color);
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            z-index: 150;
            display: flex;
            align-items: flex-end;
            min-height: 50px;
        }

        body.maximized header,
        body.maximized footer {
            display: none;
        }

        body.maximized .ruler-bar {
            top: 0;
        }

        body.maximized .report-container {
            padding-top: 80px;
            min-height: 100vh;
            margin: 0;
        }

        body.maximized .report-display {
            border-radius: 0;
            border: none;
        }

        body.maximized .ruler {
            top: 42px;
        }

        .ruler-content {
            position: relative;
            font-family: 'Courier New', Courier, monospace;
            font-size: var(--report-font-size, 11px);
            padding: 4px 20px 0 30px;
            white-space: nowrap;
            transform-origin: left top;
            flex: 1;
            line-height: 1.4;
        }

        .ruler-numbers {
            color: var(--accent-primary);
            font-weight: bold;
            white-space: pre;
        }

        .ruler-ticks {
            color: var(--text-secondary);
            white-space: pre;
        }

        /* Column highlight toggle button - positioned left of line toggle */
        .column-toggle-ruler {
            margin: 0 4px 4px 10px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            flex-shrink: 0;
            align-self: flex-end;
        }

        .column-toggle-ruler:hover,
        .column-toggle-ruler.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Line toggle button - positioned left of ruler ticks */
        .line-toggle-ruler {
            margin: 0 8px 4px 0;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            flex-shrink: 0;
            align-self: flex-end;
        }

        /* Cursor position indicator - positioned on right side of ruler */
        .ruler-cursor-position {
            margin: 0 20px 4px 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 2px 10px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
            align-self: flex-end;
        }

        .line-toggle-ruler:hover,
        .line-toggle-ruler.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .width-dropdown:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.active-indicator {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
            position: relative;
        }

        .btn.active-indicator::after {
            content: '‚óè';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 16px;
            color: #2ecc71;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        input[type="text"],
        input[type="number"],
        select {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.2);
        }

        input[type="color"] {
            width: 36px;
            height: 28px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .search-box {
            width: 250px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent-primary);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* ===========================
           REPORT DISPLAY AREA
           =========================== */
        .report-container {
            padding: 68px 30px 20px;
            min-height: calc(100vh - 250px);
        }

        .report-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: var(--report-font-size, 11px);
            white-space: pre;
            overflow-x: auto;
            background: var(--report-bg);
            color: var(--report-text);
            padding: 0;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            border-left: 70px solid var(--bg-secondary);
            position: relative;
            user-select: text;
            cursor: text;
        }

        /* Custom text selection colors */
        .report-display ::selection {
            background: #4a9eff;
            color: #ffffff;
        }

        .report-display ::-moz-selection {
            background: #4a9eff;
            color: #ffffff;
        }

        /* Light mode selection */
        body.light-mode .report-display ::selection {
            background: #0066cc;
            color: #ffffff;
        }

        body.light-mode .report-display ::-moz-selection {
            background: #0066cc;
            color: #ffffff;
        }

        /* High contrast selection */
        body.high-contrast .report-display ::selection {
            background: #00ff00;
            color: #000000;
        }

        body.high-contrast .report-display ::-moz-selection {
            background: #00ff00;
            color: #000000;
        }

        /* Light mode styles moved to theme variables
           Old .report-display.light-mode styles removed */

        .report-content {
            padding: 20px 20px 20px 15px;
            position: relative;
            user-select: text;
            overflow: visible;
        }

        /* Light mode zebra defaults */
        body.light-mode .zebra-even {
            background-color: #f5f5f5;
        }

        body.light-mode .zebra-odd {
            background-color: #ffffff;
        }

        .ruler {
            position: fixed;
            top: 105px;
            left: 0;
            right: 0;
            width: 100%;
            z-index: 10;
            font-family: 'Courier New', Courier, monospace;
            font-size: var(--report-font-size, 11px);
            background: var(--bg-tertiary);
            color: var(--ruler-text);
            padding: 14px 56px 3px;
            white-space: pre;
            overflow-x: hidden;
            border-bottom: 2px solid var(--accent-primary);
            user-select: none;
            pointer-events: none;
            transition: padding-left 0.2s ease;
        }

        .ruler > * {
            position: relative;
        }

        .ruler-content {
            flex: 1;
        }

        .cursor-position {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-primary);
            color: #ffffff;
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: auto;
        }

        .cursor-position.visible {
            opacity: 1;
        }

        .ruler.with-line-numbers {
            padding-left: 124px;  /* 60px width + 10px padding + 1px border + 10px margin + 20px base padding + 23px alignment adjustment */
        }

        .report-content {
            padding: 20px;
            position: relative;
        }

        .report-page {
            white-space: pre;
            position: relative;
            user-select: text;
        }

        /* Watermark overlay using pseudo-element */
        .report-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--watermark-image, none);
            background-repeat: no-repeat;
            background-position: var(--watermark-position, left top);
            background-size: var(--watermark-size, auto);
            pointer-events: none;
            z-index: 2;
        }

        .report-line {
            padding: 2px 5px;
            transition: background-color 0.2s ease;
            position: relative;
            z-index: 0;
            cursor: text;
            min-height: 1.2em;
            line-height: 1.2;
        }

        .line-number {
            position: absolute;
            left: -5.5em;
            width: 6em;
            color: var(--text-secondary);
            text-align: right;
            padding-right: 0.3em;
            user-select: none;
            font-size: 0.9em;
            cursor: default;
            overflow: visible;
        }

        .line-content {
            display: inline;
            white-space: pre;
            user-select: text;
            cursor: text;
        }

        /* Column highlight indicator */
        .column-highlight {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 1ch;
            background-color: rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .column-highlight.visible {
            display: block;
        }

        /* Cursor indicator */
        .cursor-indicator {
            position: absolute;
            width: 2px;
            height: 1.2em;
            background-color: red;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        .cursor-indicator.visible {
            display: block;
        }

        .report-line.zebra-even {
            background-color: var(--zebra-color1);
        }

        .report-line.zebra-odd {
            background-color: var(--zebra-color2);
        }

        .page-separator {
            margin: 20px 0;
            text-align: left;
            position: relative;
            padding-left: 20px;
            user-select: none;
            cursor: default;
        }

        .page-label {
            display: inline-block;
            background: var(--bg-secondary);
            color: var(--accent-primary);
            padding: 5px 15px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 5px;
        }

        .separator-line {
            border: none;
            border-top: 2px solid var(--accent-primary);
            margin: 5px 0 15px 0;
            opacity: 0.3;
        }

        /* ===========================
           SEARCH HIGHLIGHTING
           =========================== */
        .search-highlight {
            background-color: var(--highlight-color);
            color: #000;
            padding: 1px 2px;
            border-radius: 2px;
        }

        .search-highlight.current {
            background-color: #ff6b6b;
            color: white;
            font-weight: bold;
        }

        /* ===========================
           MODALS
           =========================== */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: var(--accent-primary);
            color: white;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* ===========================
           WATERMARK CONFIGURATION
           =========================== */
        .watermark-config {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .config-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-group label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .position-btn {
            padding: 15px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
            color: var(--text-primary);
        }

        .position-btn:hover {
            border-color: var(--accent-primary);
        }

        .position-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .slider-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-control input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
        }

        .slider-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
        }

        .slider-value {
            min-width: 50px;
            text-align: right;
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .watermark-preview {
            background: var(--report-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .watermark-preview img {
            max-width: 100%;
            max-height: 100%;
            opacity: 0.3;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upload-area:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .upload-area.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        /* ===========================
           PAGE RANGE TABLE
           =========================== */
        .ranges-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .ranges-table th,
        .ranges-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .ranges-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .ranges-table td {
            font-size: 13px;
        }

        .ranges-table tr:hover {
            background: var(--bg-tertiary);
        }

        .range-input {
            width: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        /* ===========================
           FOOTER
           =========================== */
        footer {
            background: var(--bg-secondary);
            padding: 15px 30px;
            border-top: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .footer-info {
            display: flex;
            gap: 30px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .footer-info span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .footer-info strong {
            color: var(--accent-primary);
        }

        /* ===========================
           PROGRESS INDICATOR
           =========================== */
        .progress-overlay {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .progress-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .progress-content {
            background: var(--bg-secondary);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .progress-title {
            font-size: 18px;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), #ff8fa3);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .progress-cancel-btn {
            margin-top: 12px;
            padding: 6px 20px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .progress-cancel-btn:hover {
            color: var(--text-primary);
            border-color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        /* ===========================
           TOAST NOTIFICATIONS
           =========================== */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-left: 4px solid var(--accent-primary);
            z-index: 3000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        .toast.active {
            display: block;
        }

        .toast.error {
            border-left-color: #e74c3c;
        }

        .toast.success {
            border-left-color: #2ecc71;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* ===========================
           EMPTY STATE
           =========================== */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .empty-state-subtext {
            font-size: 14px;
            opacity: 0.7;
        }

        /* ===========================
           RESPONSIVE DESIGN
           =========================== */
        @media (max-width: 1024px) {
            .toolbar-title {
                font-size: 16px;
            }

            .search-container {
                max-width: 300px;
            }
        }

        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 10px;
            }

            .toolbar-title {
                display: none;
            }

            .search-container {
                order: 3;
                width: 100%;
                max-width: none;
            }

            .file-name {
                order: 2;
                max-width: 150px;
            }

            .settings-panel {
                right: 10px;
                left: 10px;
                width: auto;
            }

            .ruler-bar {
                top: 85px;
            }

            .ruler {
                top: 125px;
            }

            .position-indicator {
                font-size: 11px;
                min-width: 70px;
            }

            .watermark-config {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            header {
                padding: 8px 12px;
            }

            .upload-btn {
                font-size: 12px;
                padding: 6px 12px;
            }

            .ruler-bar {
                padding: 6px 12px;
                gap: 8px;
            }

            .position-indicator {
                display: none;
            }
        }

        /* ===========================
           PRINT STYLES
           =========================== */
        @media print {
            body {
                background: white;
                color: black;
            }

            header,
            .control-panel,
            footer,
            .modal,
            .toast {
                display: none !important;
            }

            .report-display {
                border: none;
                padding: 0;
            }

            .page-separator {
                page-break-after: always;
            }

            #reportDisplay.printing {
                height: auto !important;
                overflow: visible !important;
            }
        }

        /* ===========================
           DRAG AND DROP FILE UPLOAD
           =========================== */
        .drop-zone {
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            background: var(--bg-tertiary);
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 20px 0;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.6;
        }

        .drop-zone-text {
            font-size: 16px;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .drop-zone-subtext {
            font-size: 13px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <!-- Main Toolbar (Single Row) -->
    <header>
        <div class="toolbar">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                üìÅ Open File
            </button>
            <input type="file" id="fileInput" accept=".txt,.TXT" style="display: none;" onchange="handleFileSelect(event)">

            <h1 class="toolbar-title">üìÑ Report/Spoolfile Viewer</h1>

            <div class="search-container">
                <span class="search-icon">üîç</span>
                <input type="text" id="searchBox" placeholder="Search..." onkeyup="handleSearchInput(event)">
                <span class="match-info" id="matchInfo"></span>
                <button class="search-nav-btn" onclick="previousSearchResult()" title="Previous match">‚óÑ</button>
                <button class="search-nav-btn" onclick="nextSearchResult()" title="Next match">‚ñ∫</button>
                <button class="clear-search-btn" id="clearSearchBtn" onclick="clearSearch()" title="Clear search">√ó</button>
            </div>

            <button class="case-sensitive-btn" id="caseSensitiveBtn" onclick="toggleCaseSensitive()" title="Case sensitive search">Aa</button>

            <select id="zoomDropdown" class="zoom-dropdown-toolbar" onchange="setZoomLevel(this.value)">
                <option value="50">50%</option>
                <option value="75">75%</option>
                <option value="100">100%</option>
                <option value="125">125%</option>
                <option value="150">150%</option>
                <option value="200">200%</option>
                <option value="fit" selected>Fit Width</option>
            </select>

            <select id="widthSelect" class="zoom-dropdown-toolbar" onchange="changeWidth()">
                <option value="auto" selected>Auto 132</option>
                <option value="80">80</option>
                <option value="132">132</option>
                <option value="160">160</option>
                <option value="198">198</option>
                <option value="255">255</option>
            </select>

            <div id="pageJumpContainer" class="search-container" style="width: 110px; min-width: 110px; max-width: 110px; padding: 4px 6px;">
                <span class="search-icon" style="font-size: 12px;" title="Jump to page">üìÑ</span>
                <input type="number" id="pageJumpInput" placeholder="Pg" min="1"
                    style="width: 38px; padding: 3px 4px; font-size: 13px;" onkeypress="handlePageJumpKey(event)" title="Enter page number and press Enter">
                <button class="search-nav-btn" style="padding: 3px 8px; font-size: 13px;" onclick="jumpToPage()" title="Jump to page">Go</button>
            </div>

            <button class="settings-btn" onclick="toggleSettingsPanel()" title="Settings">‚öôÔ∏è</button>

            <span class="file-type-indicator" id="fileTypeIndicator" title="File format type"></span>
            <span class="file-name" id="fileName">No file loaded</span>
        </div>
    </header>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="settings-panel">
        <div class="settings-header">
            <h3>‚öôÔ∏è Settings</h3>
            <button class="close-btn" onclick="toggleSettingsPanel()">‚úï</button>
        </div>

        <div class="settings-content">
            <!-- Theme Section -->
            <div class="settings-section">
                <label class="settings-label">Theme</label>
                <div class="theme-options">
                    <label class="radio-option">
                        <input type="radio" name="theme" value="light" onchange="setTheme('light')">
                        <span>Light</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="theme" value="dark" checked onchange="setTheme('dark')">
                        <span>Dark</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="theme" value="high-contrast" onchange="setTheme('high-contrast')">
                        <span>High Contrast</span>
                    </label>
                </div>
            </div>

            <!-- Display Section -->
            <div class="settings-section">
                <label class="settings-label">Display</label>
                <label class="checkbox-option">
                    <input type="checkbox" id="zebraToggle" onchange="toggleZebra()">
                    <span>Zebra striping</span>
                </label>
                <div class="zebra-colors" id="zebraColorControls" style="display: none;">
                    <label>Even <input type="color" id="zebraColor1" value="#1a1a2e" onchange="updateZebraColors()"></label>
                    <label>Odd <input type="color" id="zebraColor2" value="#0f3460" onchange="updateZebraColors()"></label>
                    <button class="reset-colors-btn" onclick="resetZebraColors()" title="Reset to default colors">Reset</button>
                </div>
            </div>

            <!-- Page Mode Section -->
            <div class="settings-section">
                <label class="settings-label">Page Mode</label>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="pageMode" value="dynamic" checked onchange="changePageMode()">
                        <span>Dynamic</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="pageMode" value="66" onchange="changePageMode()">
                        <span>Fixed 66</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="pageMode" value="88" onchange="changePageMode()">
                        <span>Fixed 88</span>
                    </label>
                </div>
            </div>

            <!-- Large File Settings -->
            <div class="settings-section">
                <label class="settings-label">Large Files (>10K lines)</label>
                <div class="config-group" style="margin-bottom: 12px;">
                    <label style="font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; display: block;">
                        Pages to render at once:
                    </label>
                    <select id="pagestoRenderSelect" onchange="changePagesToRender()" style="
                        width: 100%;
                        padding: 8px;
                        background: var(--bg-tertiary);
                        color: var(--text-primary);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        font-size: 14px;
                    ">
                        <option value="1">1 page (Maximum speed)</option>
                        <option value="3" selected>3 pages (Recommended)</option>
                        <option value="5">5 pages (More context)</option>
                        <option value="10">10 pages (High memory)</option>
                    </select>
                </div>
                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                    üí° Tip: Scroll to top/bottom to auto-load more pages
                </div>
            </div>

            <!-- Tools Section -->
            <div class="settings-section">
                <label class="settings-label">Tools</label>
                <button class="tool-btn" onclick="openWatermarkModal(); toggleSettingsPanel();">üé® Watermark...</button>
                <button class="tool-btn" onclick="openRangesModal(); toggleSettingsPanel();" id="rangesBtn">üìä Ranges...</button>
                <div style="display: flex; align-items: center; gap: 8px; margin: 4px 0;">
                    <label style="font-size: 12px; color: var(--text-secondary); white-space: nowrap;">PDF Page:</label>
                    <select id="pdfPageSizeSelect" onchange="AppState.pdfPageSize = this.value" style="
                        flex: 1; padding: 4px 6px; font-size: 12px;
                        background: var(--bg-tertiary); color: var(--text-primary);
                        border: 1px solid var(--border-color); border-radius: 3px;">
                        <option value="greenbar" selected>Greenbar 14‚Öû√ó11"</option>
                        <option value="letter">US Letter 11√ó8¬Ω"</option>
                        <option value="a4">A4 Landscape</option>
                        <option value="a3">A3 Landscape</option>
                    </select>
                </div>
                <div style="display: flex; align-items: center; gap: 6px; margin: 4px 0;">
                    <input type="checkbox" id="pdfZebraToggle" onchange="AppState.pdfZebraEnabled = this.checked" style="margin: 0;">
                    <label for="pdfZebraToggle" style="font-size: 12px; color: var(--text-secondary); cursor: pointer;">Zebra striping in PDF</label>
                </div>
                <button class="tool-btn" onclick="exportToPDF(); toggleSettingsPanel();">üìÑ Export PDF</button>
            </div>

            <!-- About -->
            <div class="settings-section" style="border-top: 1px solid var(--border-color); padding-top: 12px;">
                <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.5;">
                    PDF export powered by <strong>jsPDF 2.5.1</strong><br>
                    Copyright &copy; James Hall, yWorks GmbH<br>
                    Licensed under the MIT License
                </div>
            </div>
        </div>
    </div>

    <!-- Search Results Panel -->
    <div id="searchResultsPanel" class="search-results-panel">
        <div class="search-results-header">
            <h4 id="searchResultsPanelTitle">Search Results</h4>
            <button class="search-results-close" onclick="toggleSearchResultsPanel()">&times;</button>
        </div>
        <div class="search-results-content" id="searchResultsContent">
            <!-- Search results will be populated here -->
        </div>
    </div>

    <!-- Enhanced Ruler Bar -->
    <div class="ruler-bar">
        <button class="column-toggle-ruler active" id="columnToggleBtn" onclick="toggleColumnHighlight()" title="Toggle column highlight">|</button>
        <button class="line-toggle-ruler" id="lineToggleBtn" onclick="toggleLineNumbers()" title="Toggle line numbers">#</button>
        <div class="ruler-content" id="stickyRulerContent">
            <!-- Ruler content will be generated here -->
        </div>
        <div class="ruler-cursor-position" id="rulerCursorPosition">Ln 1 Col 1</div>
    </div>

    <!-- Report Display -->
    <div class="report-container">
        <div id="reportDisplay" class="report-display">
            <div class="empty-state">
                <div class="empty-state-icon">üìÑ</div>
                <div class="empty-state-text">No report loaded</div>
                <div class="empty-state-subtext">Click "Open File" or drag & drop a .TXT file to begin</div>
            </div>
        </div>
    </div>

    <!-- Column highlight indicator -->
    <div id="columnHighlight" class="column-highlight"></div>

    <!-- Footer -->
    <footer>
        <div class="footer-info">
            <span><strong>Page:</strong> <span id="currentPage">-</span> of <span id="totalPages">-</span></span>
            <span><strong>Lines:</strong> <span id="totalLines">-</span></span>
            <span><strong>File Size:</strong> <span id="fileSize">-</span></span>
        </div>
        <div class="footer-info">
            <span>Keyboard: Ctrl+O (Open) | Ctrl+F (Search) | Ctrl+G (Jump) | Ctrl+E (Export) | Ctrl+/- (Zoom) | F3 (Next) | Ctrl+M/F11 (Maximize)</span>
        </div>
    </footer>

    <!-- Watermark Configuration Modal -->
    <div id="watermarkModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">üíß Watermark Configuration</h2>
                <button class="close-btn" onclick="closeWatermarkModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="watermark-config">
                    <div class="config-section">
                        <div class="config-group">
                            <label>Upload Watermark Image</label>
                            <div class="upload-area" id="watermarkUploadArea" onclick="document.getElementById('watermarkInput').click()">
                                <div style="font-size: 36px; margin-bottom: 10px;">üñºÔ∏è</div>
                                <div>Click to upload or drag & drop</div>
                                <div style="font-size: 12px; margin-top: 5px; color: var(--text-secondary);">PNG, JPG, SVG (max 5MB)</div>
                            </div>
                            <input type="file" id="watermarkInput" accept="image/*" style="display: none;" onchange="handleWatermarkUpload(event)">
                        </div>

                        <div class="config-group">
                            <label>Position</label>
                            <div class="position-grid">
                                <button class="position-btn" data-position="top-left" onclick="setWatermarkPosition('top-left')">Top Left</button>
                                <button class="position-btn" data-position="top-center" onclick="setWatermarkPosition('top-center')">Top Center</button>
                                <button class="position-btn" data-position="top-right" onclick="setWatermarkPosition('top-right')">Top Right</button>
                                <button class="position-btn" data-position="middle-left" onclick="setWatermarkPosition('middle-left')">Middle Left</button>
                                <button class="position-btn active" data-position="center" onclick="setWatermarkPosition('center')">Center</button>
                                <button class="position-btn" data-position="middle-right" onclick="setWatermarkPosition('middle-right')">Middle Right</button>
                                <button class="position-btn" data-position="bottom-left" onclick="setWatermarkPosition('bottom-left')">Bottom Left</button>
                                <button class="position-btn" data-position="bottom-center" onclick="setWatermarkPosition('bottom-center')">Bottom Center</button>
                                <button class="position-btn" data-position="bottom-right" onclick="setWatermarkPosition('bottom-right')">Bottom Right</button>
                            </div>
                        </div>

                        <div class="config-group">
                            <label>Rotation: <span id="rotationValue">0¬∞</span></label>
                            <div class="slider-control">
                                <input type="range" id="rotationSlider" min="-180" max="180" value="0" oninput="updateRotation(this.value)">
                            </div>
                        </div>

                        <div class="config-group">
                            <label>Opacity: <span id="opacityValue">30%</span></label>
                            <div class="slider-control">
                                <input type="range" id="opacitySlider" min="0" max="100" value="30" oninput="updateOpacity(this.value)">
                            </div>
                        </div>

                        <div class="config-group">
                            <label>Scale: <span id="scaleValue">1.0x</span></label>
                            <div class="slider-control">
                                <input type="range" id="scaleSlider" min="50" max="200" value="100" oninput="updateScale(this.value)">
                            </div>
                        </div>

                        <div class="config-group">
                            <label>
                                <input type="checkbox" id="watermarkEnabled" onchange="toggleWatermark()"> Enable Watermark
                            </label>
                        </div>
                    </div>

                    <div class="config-section">
                        <div class="config-group">
                            <label>Preview</label>
                            <div class="watermark-preview" id="watermarkPreview">
                                <div style="color: var(--text-secondary); text-align: center;">
                                    <div style="font-size: 48px; margin-bottom: 10px;">üñºÔ∏è</div>
                                    <div>Upload an image to preview</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeWatermarkModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Page Ranges Modal -->
    <div id="rangesModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">üìë Page Ranges</h2>
                <button class="close-btn" onclick="closeRangesModal()">&times;</button>
            </div>
            <div class="modal-body">
                <table class="ranges-table">
                    <thead>
                        <tr>
                            <th>Section Name</th>
                            <th>Start Page</th>
                            <th>Page Count</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="rangesTableBody">
                        <!-- Ranges will be added here dynamically -->
                    </tbody>
                </table>
                <button class="btn" onclick="addNewRange()">+ Add Range</button>
                <label style="margin-left: 20px;">
                    <input type="checkbox" id="showRangesOnly" onchange="toggleRangesFilter()"> Show Ranges Only
                </label>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeRangesModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Progress Overlay -->
    <div id="progressOverlay" class="progress-overlay">
        <div class="progress-content">
            <div class="progress-title" id="progressTitle">Processing...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">0%</div>
            <button id="progressCancel" class="progress-cancel-btn" style="display: none;" onclick="cancelPdfExport()">Cancel</button>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- CDN Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Main Application Script -->
    <script>
        // ===========================
        // STATE MANAGEMENT
        // ===========================
        const AppState = {
            // File data
            rawContent: null,
            lines: [],
            pages: [],
            fileName: '',
            fileSize: 0,
            fileType: 'Plain', // 'Channel', 'FormFeed', or 'Plain'

            // View settings
            zebraEnabled: false,
            zebraColor1: '#1a1a2e',
            zebraColor2: '#0f3460',
            zoomLevel: 'fit',
            showLineNumbers: true,
            showRuler: true, // Always true in new design
            columnHighlightEnabled: true, // Column highlight on hover
            theme: 'dark',

            // Page settings
            pageLengthMode: 'dynamic',
            fixedPageLength: 66,
            detectedWidth: 132,

            // Page ranges
            pageRanges: [],
            showRangesOnly: false,

            // Search
            searchTerm: '',
            searchResults: [],
            searchResultsByPage: {},
            currentSearchIndex: -1,
            searchDebounceTimer: null,

            // Watermark
            watermark: {
                enabled: false,
                imageData: null,
                imageSrc: null,
                position: 'center',
                rotation: 0,
                opacity: 30,
                scale: 100
            },

            // PDF export
            pdfPageSize: 'greenbar',
            pdfZebraEnabled: false,

            // UI state
            currentPage: 1,
            settingsPanelOpen: false,
            pdfExportCancelled: false
        };

        // ===========================
        // VIRTUAL SCROLLING
        // ===========================
        class VirtualScroller {
            constructor(container, itemHeight) {
                this.container = container;
                this.itemHeight = itemHeight; // 16px per line
                this.viewportHeight = 0;
                this.scrollTop = 0;
                this.visibleStartIndex = 0;
                this.visibleEndIndex = 0;
                this.bufferSize = 50; // Extra rows above/below viewport
                this.totalItems = 0;
                this.renderCallback = null;
                this.rafPending = false;
                this.scrollListener = null;
                this.resizeObserver = null;
            }

            init(totalItems, renderCallback) {
                this.totalItems = totalItems;
                this.renderCallback = renderCallback;
                this.viewportHeight = this.container.clientHeight;

                // Create structure: topSpacer + content + bottomSpacer
                this.topSpacer = document.createElement('div');
                this.bottomSpacer = document.createElement('div');
                this.content = document.createElement('div');
                this.content.setAttribute('role', 'region');
                this.content.setAttribute('aria-label', 'Report content');

                this.container.innerHTML = '';
                this.container.appendChild(this.topSpacer);
                this.container.appendChild(this.content);
                this.container.appendChild(this.bottomSpacer);

                this.updateVisibleRange();
                this.render();

                // Passive scroll listener for performance
                this.scrollListener = () => this.onScroll();
                this.container.addEventListener('scroll', this.scrollListener, { passive: true });

                // Handle resize
                this.resizeObserver = new ResizeObserver(() => this.onResize());
                this.resizeObserver.observe(this.container);
            }

            onScroll() {
                if (this.rafPending) return;

                this.rafPending = true;
                requestAnimationFrame(() => {
                    this.scrollTop = this.container.scrollTop;
                    const newStartIndex = Math.floor(this.scrollTop / this.itemHeight);

                    // Re-render if scrolled more than 10 rows
                    if (Math.abs(newStartIndex - this.visibleStartIndex) > 10) {
                        this.updateVisibleRange();
                        this.render();
                    }

                    this.rafPending = false;
                });
            }

            onResize() {
                this.viewportHeight = this.container.clientHeight;
                this.updateVisibleRange();
                this.render();
            }

            updateVisibleRange() {
                this.visibleStartIndex = Math.max(0,
                    Math.floor(this.scrollTop / this.itemHeight) - this.bufferSize);
                this.visibleEndIndex = Math.min(this.totalItems,
                    Math.ceil((this.scrollTop + this.viewportHeight) / this.itemHeight) + this.bufferSize);
            }

            render() {
                // Update spacers to maintain scroll position
                this.topSpacer.style.height = (this.visibleStartIndex * this.itemHeight) + 'px';
                this.bottomSpacer.style.height =
                    ((this.totalItems - this.visibleEndIndex) * this.itemHeight) + 'px';

                // Render visible items via callback
                if (this.renderCallback) {
                    this.renderCallback(this.visibleStartIndex, this.visibleEndIndex, this.content);
                }
            }

            scrollToIndex(index) {
                const targetScroll = index * this.itemHeight;
                this.container.scrollTop = targetScroll;
            }

            destroy() {
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                    this.resizeObserver = null;
                }
                if (this.scrollListener) {
                    this.container.removeEventListener('scroll', this.scrollListener);
                    this.scrollListener = null;
                }
            }
        }

        let virtualScroller = null;

        // ===========================
        // INITIALIZATION
        // ===========================
        window.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            setupDragAndDrop();
            setupKeyboardShortcuts();
            applyZebraColors();
            setupRulerSync();
        });

        function setupRulerSync() {
            // Sync ruler horizontal position with report horizontal scroll
            const reportDisplay = document.getElementById('reportDisplay');
            if (reportDisplay) {
                reportDisplay.addEventListener('scroll', alignRuler);
            }
            window.addEventListener('resize', () => requestAnimationFrame(alignRuler));
        }

        // Load saved settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('reportViewerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    if (settings.zebraColor1) AppState.zebraColor1 = settings.zebraColor1;
                    if (settings.zebraColor2) AppState.zebraColor2 = settings.zebraColor2;
                    if (settings.zebraEnabled !== undefined) AppState.zebraEnabled = settings.zebraEnabled;
                    if (settings.theme) AppState.theme = settings.theme;

                    document.getElementById('zebraColor1').value = AppState.zebraColor1;
                    document.getElementById('zebraColor2').value = AppState.zebraColor2;
                    document.getElementById('zebraToggle').checked = AppState.zebraEnabled;

                    // Apply theme
                    setTheme(AppState.theme);

                    // Show/hide zebra colors
                    if (AppState.zebraEnabled) {
                        document.getElementById('zebraColorControls').style.display = 'flex';
                    }

                    applyZebraColors();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                zebraColor1: AppState.zebraColor1,
                zebraColor2: AppState.zebraColor2,
                zebraEnabled: AppState.zebraEnabled,
                theme: AppState.theme
            };
            localStorage.setItem('reportViewerSettings', JSON.stringify(settings));
        }

        // ===========================
        // UI CONTROLS
        // ===========================

        // Toggle Settings Panel
        function toggleSettingsPanel() {
            const panel = document.getElementById('settingsPanel');
            AppState.settingsPanelOpen = !AppState.settingsPanelOpen;

            if (AppState.settingsPanelOpen) {
                panel.classList.add('active');
            } else {
                panel.classList.remove('active');
            }
        }

        // Close settings panel when clicking outside
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('settingsPanel');
            const settingsBtn = document.querySelector('.settings-btn');

            if (AppState.settingsPanelOpen &&
                !panel.contains(event.target) &&
                !settingsBtn.contains(event.target)) {
                toggleSettingsPanel();
            }
        });

        // Set Theme
        function setTheme(theme) {
            AppState.theme = theme;

            // Remove all theme classes
            document.body.classList.remove('light-mode', 'high-contrast');

            // Apply theme
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            } else if (theme === 'high-contrast') {
                document.body.classList.add('high-contrast');
            }

            // Update radio buttons
            document.querySelectorAll('input[name="theme"]').forEach(radio => {
                radio.checked = (radio.value === theme);
            });

            saveSettings();
        }

        // Set Zoom Level
        function setZoomLevel(value) {
            if (value === 'fit') {
                // Fit to width logic - calculate zoom to fit report width to viewport
                const reportDisplay = document.getElementById('reportDisplay');
                if (reportDisplay && AppState.detectedWidth > 0) {
                    const viewportWidth = reportDisplay.clientWidth;
                    const charWidth = 6.6; // Approximate width of a character at 11px (100% zoom)
                    const contentPadding = 40; // Left + right padding
                    const lineNumberWidth = AppState.showLineNumbers ? 81 : 0;

                    // Calculate required width for the report
                    const requiredWidth = (AppState.detectedWidth * charWidth) + contentPadding + lineNumberWidth;

                    // Calculate zoom percentage
                    let fitZoom = Math.floor((viewportWidth / requiredWidth) * 100);

                    // Clamp between 50% and 200%
                    fitZoom = Math.max(50, Math.min(200, fitZoom));

                    AppState.zoomLevel = fitZoom;

                    // Calculate font size
                    const fontSize = Math.round(11 * (fitZoom / 100)) + 'px';
                    document.documentElement.style.setProperty('--report-font-size', fontSize);

                    showToast(`Zoom set to ${fitZoom}% (Fit Width)`, 'success');
                } else {
                    AppState.zoomLevel = 100;
                    document.documentElement.style.setProperty('--report-font-size', '11px');
                }
            } else {
                AppState.zoomLevel = parseInt(value);

                const fontSizeMap = {
                    50: '5.5px',
                    75: '8px',
                    100: '11px',
                    125: '14px',
                    150: '16px',
                    200: '22px'
                };

                const fontSize = fontSizeMap[AppState.zoomLevel] || '11px';
                document.documentElement.style.setProperty('--report-font-size', fontSize);
            }

            // Clear cached character width for mousemove handler
            const reportDisplay = document.getElementById('reportDisplay');
            if (reportDisplay) {
                delete reportDisplay._cachedCharWidth;
            }

            // Re-align ruler with text after zoom change
            requestAnimationFrame(alignRuler);

            // Update dropdown
            document.getElementById('zoomDropdown').value = value;
        }

        // Handle Search Input with Debouncing
        function handleSearchInput(event) {
            const searchBox = document.getElementById('searchBox');
            const clearBtn = document.getElementById('clearSearchBtn');

            // Handle Escape key
            if (event.key === 'Escape') {
                clearSearch();
                return;
            }

            // Show/hide clear button
            if (searchBox.value.length > 0) {
                clearBtn.classList.add('visible');
            } else {
                clearBtn.classList.remove('visible');
            }

            // Debounce search
            if (AppState.searchDebounceTimer) {
                clearTimeout(AppState.searchDebounceTimer);
            }

            AppState.searchDebounceTimer = setTimeout(() => {
                if (event.key === 'Enter') {
                    performSearch();
                } else if (searchBox.value.length >= 2) {
                    performSearch();
                }
            }, 300);
        }

        // Update search results display
        function updateSearchDisplay() {
            const matchInfo = document.getElementById('matchInfo');

            if (AppState.searchResults.length > 0) {
                const currentIndex = AppState.currentSearchIndex + 1;
                matchInfo.textContent = `${currentIndex}/${AppState.searchResults.length}`;
                matchInfo.classList.add('visible');
            } else if (AppState.searchTerm && AppState.searchResults.length === 0) {
                matchInfo.textContent = '0/0';
                matchInfo.classList.add('visible');
            } else {
                matchInfo.classList.remove('visible');
            }
        }

        // Updated Toggle Zebra to show/hide color controls
        function toggleZebra() {
            AppState.zebraEnabled = document.getElementById('zebraToggle').checked;
            const colorControls = document.getElementById('zebraColorControls');

            if (AppState.zebraEnabled) {
                colorControls.style.display = 'flex';
            } else {
                colorControls.style.display = 'none';
            }

            applyZebraColors();
            saveSettings();
        }

        // Updated Change Page Mode for radio buttons
        function changePageMode() {
            const selectedMode = document.querySelector('input[name="pageMode"]:checked').value;

            if (selectedMode === 'dynamic') {
                AppState.pageLengthMode = 'dynamic';
            } else {
                AppState.pageLengthMode = parseInt(selectedMode);
                AppState.fixedPageLength = parseInt(selectedMode);
            }

            if (AppState.lines.length > 0) {
                detectPages();
                renderReport();
            }
        }

        // Updated Toggle Line Numbers
        function toggleLineNumbers() {
            AppState.showLineNumbers = !AppState.showLineNumbers;
            const toggleBtn = document.getElementById('lineToggleBtn');

            if (AppState.showLineNumbers) {
                toggleBtn.classList.add('active');
            } else {
                toggleBtn.classList.remove('active');
            }

            renderReport();
        }

        // Toggle Column Highlight
        function toggleColumnHighlight() {
            AppState.columnHighlightEnabled = !AppState.columnHighlightEnabled;
            const toggleBtn = document.getElementById('columnToggleBtn');

            if (AppState.columnHighlightEnabled) {
                toggleBtn.classList.add('active');
            } else {
                toggleBtn.classList.remove('active');
                // Hide the highlight when disabled
                const columnHighlight = document.getElementById('columnHighlight');
                if (columnHighlight) {
                    columnHighlight.classList.remove('visible');
                }
            }
        }

        // Update Position Indicator
        function updatePositionIndicator(line, col) {
            const indicator = document.getElementById('positionIndicator');
            indicator.textContent = `Ln ${line} Col ${col}`;
        }

        // Toggle Case Sensitive Search
        function toggleCaseSensitive() {
            const btn = document.getElementById('caseSensitiveBtn');
            const isActive = btn.classList.toggle('active');

            // If search is already active, re-run it with new case sensitivity
            if (AppState.searchTerm && AppState.lines.length > 0) {
                performSearch();
            }
        }

        // Check if case sensitive is active
        function isCaseSensitive() {
            const btn = document.getElementById('caseSensitiveBtn');
            return btn && btn.classList.contains('active');
        }

        // ===========================
        // FILE HANDLING
        // ===========================
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadFile(file);
            }
        }

        function loadFile(file) {
            showProgress('Loading file...', 0);

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    AppState.rawContent = e.target.result;
                    AppState.fileName = file.name;
                    AppState.fileSize = file.size;

                    // Clear page ranges when loading a new file
                    AppState.pageRanges = [];
                    AppState.showRangesOnly = false;

                    // Update the checkbox UI
                    const rangesCheckbox = document.getElementById('showRangesOnly');
                    if (rangesCheckbox) {
                        rangesCheckbox.checked = false;
                    }

                    updateProgress(30, 'Parsing content...');

                    // Use setTimeout to allow UI to update
                    setTimeout(() => {
                        parseReportFile();
                        updateProgress(60, 'Detecting pages...');

                        setTimeout(() => {
                            detectPages();
                            detectReportWidth();
                            updateProgress(80, 'Rendering display...');

                            setTimeout(() => {
                                renderReport();
                                updateFileInfo();

                                // Apply Fit Width zoom by default
                                setZoomLevel('fit');
                                document.getElementById('zoomDropdown').value = 'fit';

                                updateProgress(100, 'Complete!');

                                setTimeout(() => {
                                    hideProgress();
                                    showToast(`File loaded! Width: ${AppState.detectedWidth} columns`, 'success');
                                }, 500);
                            }, 100);
                        }, 100);
                    }, 100);
                } catch (error) {
                    hideProgress();
                    showToast('Error loading file: ' + error.message, 'error');
                    console.error('File load error:', error);
                }
            };

            reader.onerror = function() {
                hideProgress();
                showToast('Error reading file', 'error');
            };

            reader.readAsText(file);
        }

        // ===========================
        // FILE PARSING
        // ===========================
        function parseReportFile() {
            const lines = AppState.rawContent.split(/\r?\n/);
            AppState.lines = [];
            let currentPage = 1;

            // First check if file contains FormFeed characters (ASCII 12 or \f)
            // If it does, it's an ASCII report with FormFeeds, not ASA carriage control
            const hasFormFeeds = AppState.rawContent.includes('\f') ||
                                 /\x0C/.test(AppState.rawContent);

            // Detect if file uses ASA carriage control (first char of every line is control)
            // Only check for ASA format if there are NO FormFeed characters
            let usesASACarriageControl = false;
            if (!hasFormFeeds) {
                // Check first non-comment, non-empty lines
                let asaIndicatorCount = 0;
                let checkedLines = 0;
                for (let i = 0; i < Math.min(20, lines.length) && checkedLines < 10; i++) {
                    // Skip JES2 comments and empty lines
                    if (lines[i].startsWith('*$') || lines[i].length === 0) continue;

                    checkedLines++;
                    const firstChar = lines[i].charAt(0);
                    // ASA control characters: 1 (new page), 0 (double space), - (single space), space (normal), + (overprint)
                    if (firstChar === '1' || firstChar === '0' || firstChar === '-' || firstChar === ' ' || firstChar === '+') {
                        asaIndicatorCount++;
                    }
                }
                // If more than 70% of checked lines have ASA control characters, assume ASA format
                if (checkedLines > 0 && asaIndicatorCount / checkedLines > 0.7) {
                    usesASACarriageControl = true;
                }
            }

            // Store file type in AppState
            AppState.fileType = hasFormFeeds ? 'FormFeed' : (usesASACarriageControl ? 'Channel' : 'Plain');

            lines.forEach((rawLine, index) => {
                // Skip JES2 spool commands (lines starting with *$)
                if (rawLine.startsWith('*$')) {
                    return;
                }

                if (rawLine.length === 0) {
                    // Empty line
                    const lineObj = {
                        lineNumber: index + 1,
                        rawText: rawLine,
                        displayText: '',
                        controlChar: '',
                        pageNumber: currentPage,
                        isPageBreak: false,
                        hasMatch: false
                    };
                    AppState.lines.push(lineObj);
                    return;
                }

                const controlChar = rawLine.charAt(0);
                let displayText = rawLine;
                let isPageBreak = false;

                // Check for form feed character (ASCII 12)
                const isFormFeed = controlChar === '\f' || controlChar.charCodeAt(0) === 12;

                if (isFormFeed) {
                    // Form feed - always a page break, strip it
                    displayText = rawLine.substring(1);
                    isPageBreak = true;
                } else if (usesASACarriageControl) {
                    // ASA carriage control format - first char is always control
                    // Strip control char and the space that typically follows it
                    if (controlChar === '1') {
                        // Strip control char, and also strip following space if present
                        displayText = rawLine.substring(1);
                        if (displayText.charAt(0) === ' ') {
                            displayText = displayText.substring(1);
                        }
                        isPageBreak = true;
                    } else if (controlChar === '0' || controlChar === '-' || controlChar === ' ' || controlChar === '+') {
                        // Other carriage control chars (0=double space, -=single space, +=overprint, space=normal)
                        // Strip control char, and also strip following space if present
                        displayText = rawLine.substring(1);
                        if (displayText.charAt(0) === ' ') {
                            displayText = displayText.substring(1);
                        }
                    }
                } else {
                    // No carriage control - keep line as-is unless it's a form feed
                    displayText = rawLine;
                }

                const lineObj = {
                    lineNumber: index + 1,
                    rawText: rawLine,
                    displayText: displayText,
                    controlChar: controlChar,
                    pageNumber: currentPage,
                    isPageBreak: isPageBreak,
                    hasMatch: false
                };

                // If this is a page break (and not the first line), increment page
                if (isPageBreak && index > 0) {
                    currentPage++;
                    lineObj.pageNumber = currentPage;
                }

                AppState.lines.push(lineObj);
            });
        }

        // ===========================
        // PAGE DETECTION
        // ===========================
        function detectPages() {
            AppState.pages = [];

            if (AppState.pageLengthMode === 'dynamic') {
                detectPagesDynamic();
            } else {
                detectPagesFixed();
            }
        }

        function detectPagesDynamic() {
            let currentPage = {
                pageNumber: 1,
                startLineNumber: 1,
                lines: [],
                hasSearchMatch: false
            };

            AppState.lines.forEach((line, index) => {
                if (line.isPageBreak && index > 0) {
                    // Finalize current page
                    currentPage.endLineNumber = AppState.lines[index - 1].lineNumber;
                    currentPage.lineCount = currentPage.lines.length;
                    AppState.pages.push(currentPage);

                    // Start new page
                    currentPage = {
                        pageNumber: currentPage.pageNumber + 1,
                        startLineNumber: line.lineNumber,
                        lines: [],
                        hasSearchMatch: false
                    };
                }

                line.pageNumber = currentPage.pageNumber;
                currentPage.lines.push(line);
            });

            // Add final page
            if (currentPage.lines.length > 0) {
                currentPage.endLineNumber = AppState.lines[AppState.lines.length - 1].lineNumber;
                currentPage.lineCount = currentPage.lines.length;
                AppState.pages.push(currentPage);
            }
        }

        function detectPagesFixed() {
            const linesPerPage = parseInt(AppState.fixedPageLength);
            let pageNumber = 1;

            for (let i = 0; i < AppState.lines.length; i += linesPerPage) {
                const pageLines = AppState.lines.slice(i, i + linesPerPage);

                pageLines.forEach(line => {
                    line.pageNumber = pageNumber;
                });

                const page = {
                    pageNumber: pageNumber,
                    startLineNumber: pageLines[0].lineNumber,
                    endLineNumber: pageLines[pageLines.length - 1].lineNumber,
                    lineCount: pageLines.length,
                    lines: pageLines,
                    hasSearchMatch: false
                };

                AppState.pages.push(page);
                pageNumber++;
            }
        }

        // ===========================
        // RENDERING
        // ===========================
        const USE_VIRTUAL_SCROLLING = false; // DISABLED - Virtual scrolling needs further optimization for files >100K lines
        const LARGE_FILE_THRESHOLD = 10000; // Lines - use page-by-page rendering above this
        let PAGES_TO_RENDER = 3; // Number of pages to render at once for large files (configurable)

        function renderReport() {
            const display = document.getElementById('reportDisplay');

            // Choose rendering strategy based on file size
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                // Large file: Page-by-page rendering
                renderPageByPage();
            } else if (USE_VIRTUAL_SCROLLING && AppState.lines.length > 1000) {
                // Medium file: Virtual scrolling
                renderReportVirtual();
            } else {
                // Small file: Traditional full rendering
                renderReportTraditional();
            }

            // Update ranges button indicator
            updateRangesIndicator();

            // Update sticky ruler bar
            updateStickyRuler();
        }

        // Page-by-page rendering for large files
        function renderPageByPage() {
            const display = document.getElementById('reportDisplay');

            // Initialize current page index if not set
            if (!AppState.currentPageIndex) {
                AppState.currentPageIndex = 0;
            }

            // Determine which pages to display
            let allPages = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                allPages = filterPagesByRanges();
            }

            // Calculate page range to render (current page +/- buffer)
            const startPage = Math.max(0, AppState.currentPageIndex - Math.floor(PAGES_TO_RENDER / 2));
            const endPage = Math.min(allPages.length, startPage + PAGES_TO_RENDER);
            const pagesToDisplay = allPages.slice(startPage, endPage);

            // Get actual page numbers being displayed
            const firstVisiblePage = pagesToDisplay[0]?.pageNumber || 1;
            const lastVisiblePage = pagesToDisplay[pagesToDisplay.length - 1]?.pageNumber || 1;
            const totalPages = allPages[allPages.length - 1]?.pageNumber || allPages.length;

            // Show navigation controls
            showPageNavigation(firstVisiblePage, lastVisiblePage, totalPages, AppState.currentPageIndex, allPages.length);

            // Render only the selected pages (traditional rendering)
            let html = '<div class="report-content">';

            pagesToDisplay.forEach((page, pageIndex) => {
                // Add page separator
                const sectionName = getSectionNameForPage(page.pageNumber);
                const pageLabelText = sectionName
                    ? `‚îÄ‚îÄ PAGE ${page.pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                    : `‚îÄ‚îÄ PAGE ${page.pageNumber} ‚îÄ‚îÄ`;
                html += `<div class="page-separator" data-page="${page.pageNumber}">`;
                html += `<div><span class="page-label">${pageLabelText}</span></div>`;
                html += `<hr class="separator-line"></div>`;

                // Create page container
                html += `<div class="report-page" data-page="${page.pageNumber}" id="page-${page.pageNumber}">`;

                // Add all lines for this page
                page.lines.forEach((line, lineIndex) => {
                    const zebraClass = AppState.zebraEnabled ? (lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd') : '';
                    html += `<div class="report-line ${zebraClass}" data-line="${line.lineNumber}" data-page="${page.pageNumber}" data-page-line="${lineIndex + 1}">`;
                    if (AppState.showLineNumbers) {
                        html += `<span class="line-number">${lineIndex + 1}</span>`;
                    }
                    html += `<span class="line-content">${escapeHtml(line.displayText)}</span>`;
                    html += `</div>`;
                });

                html += '</div>';
            });

            html += '</div>';
            display.innerHTML = html;

            // Apply watermark if enabled
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                setTimeout(() => applyWatermarkToDisplay(), 100);
            }

            // Update current page indicator in footer to match navigation bar
            if (firstVisiblePage === lastVisiblePage) {
                AppState.currentPage = firstVisiblePage;
                document.getElementById('currentPage').textContent = firstVisiblePage;
            } else {
                // Show page range in footer too
                AppState.currentPage = lastVisiblePage;
                document.getElementById('currentPage').textContent = `${firstVisiblePage}-${lastVisiblePage}`;
            }
        }

        function showPageNavigation(firstPage, lastPage, totalPages, currentIndex, totalPagesCount) {
            // Check if navigation already exists
            let navBar = document.getElementById('pageNavBar');
            if (!navBar) {
                // Create navigation bar
                navBar = document.createElement('div');
                navBar.id = 'pageNavBar';
                navBar.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: var(--bg-secondary);
                    border: 2px solid var(--border-color);
                    border-radius: 8px;
                    padding: 12px 20px;
                    display: flex;
                    gap: 12px;
                    align-items: center;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    z-index: 1000;
                    font-size: 14px;
                `;
                document.body.appendChild(navBar);

                // Setup scroll listener for auto-load
                const display = document.getElementById('reportDisplay');
                let scrollTimeout;
                display.addEventListener('scroll', function() {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => checkScrollPosition(), 150);
                });
            }

            // Determine page display text
            const pageText = firstPage === lastPage
                ? `Page <strong>${firstPage}</strong> of <strong>${totalPages}</strong>`
                : `Pages <strong>${firstPage}-${lastPage}</strong> of <strong>${totalPages}</strong>`;

            // Update navigation content
            navBar.innerHTML = `
                <button onclick="previousPage()" style="
                    padding: 8px 16px;
                    background: var(--accent-primary);
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                " ${currentIndex <= 0 ? 'disabled' : ''}>‚óÑ Previous</button>
                <span style="color: var(--text-primary); min-width: 150px; text-align: center;">
                    ${pageText}
                </span>
                <button onclick="nextPage()" style="
                    padding: 8px 16px;
                    background: var(--accent-primary);
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                " ${currentIndex >= totalPagesCount - 1 ? 'disabled' : ''}>Next ‚ñ∫</button>
                <button onclick="jumpToPagePrompt()" style="
                    padding: 8px 16px;
                    background: var(--accent-secondary);
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                ">Go to Page...</button>
            `;
        }

        function hidePageNavigation() {
            const navBar = document.getElementById('pageNavBar');
            if (navBar) {
                navBar.remove();
            }

            // Keep page jump input visible for all files
            // (removed code that was hiding it for small files)
        }

        function previousPage() {
            if (AppState.currentPageIndex > 0) {
                AppState.currentPageIndex--;
                renderReport();
                document.getElementById('reportDisplay').scrollTop = 0;
            }
        }

        function nextPage() {
            const totalPages = AppState.pages.length;
            if (AppState.currentPageIndex < totalPages - 1) {
                AppState.currentPageIndex++;
                renderReport();
                document.getElementById('reportDisplay').scrollTop = 0;
            }
        }

        function jumpToPagePrompt() {
            const totalPages = AppState.pages.length;
            const pageNum = prompt(`Enter page number (1-${totalPages}):`);
            if (pageNum) {
                const num = parseInt(pageNum);
                if (num >= 1 && num <= totalPages) {
                    AppState.currentPageIndex = num - 1;
                    renderReport();
                    document.getElementById('reportDisplay').scrollTop = 0;
                } else {
                    showToast(`Invalid page number. Enter 1-${totalPages}`, 'error');
                }
            }
        }

        function checkScrollPosition() {
            // Only run for large files with page-by-page rendering
            if (AppState.lines.length <= LARGE_FILE_THRESHOLD) return;

            const display = document.getElementById('reportDisplay');
            const scrollTop = display.scrollTop;
            const scrollHeight = display.scrollHeight;
            const clientHeight = display.clientHeight;
            const totalPages = AppState.pages.length;

            // Threshold for triggering load (100px from edge)
            const threshold = 100;

            // Check if scrolled near bottom
            if (scrollTop + clientHeight >= scrollHeight - threshold) {
                if (AppState.currentPageIndex < totalPages - 1) {
                    // Save current scroll position relative to document
                    const wasAtBottom = true;

                    AppState.currentPageIndex++;
                    renderReport();

                    // Keep scroll near bottom (show continuity)
                    requestAnimationFrame(() => {
                        display.scrollTop = threshold;
                    });
                }
            }
            // Check if scrolled near top
            else if (scrollTop <= threshold) {
                if (AppState.currentPageIndex > 0) {
                    AppState.currentPageIndex--;
                    renderReport();

                    // Keep scroll near top of new content (show continuity)
                    requestAnimationFrame(() => {
                        display.scrollTop = scrollHeight - clientHeight - threshold;
                    });
                }
            }
        }

        function jumpToPage() {
            const input = document.getElementById('pageJumpInput');
            const pageNum = parseInt(input.value);

            if (!pageNum || isNaN(pageNum)) {
                showToast('Enter a valid page number', 'error');
                return;
            }

            // Check if using page-by-page rendering (large files)
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                // Large file: Update currentPageIndex and re-render
                const totalPages = AppState.pages.length;
                if (pageNum >= 1 && pageNum <= totalPages) {
                    const pageIndex = AppState.pages.findIndex(p => p.pageNumber === pageNum);
                    if (pageIndex >= 0) {
                        AppState.currentPageIndex = pageIndex;
                        renderReport();
                        document.getElementById('reportDisplay').scrollTop = 0;
                        input.value = ''; // Clear input
                        showToast(`Jumped to page ${pageNum}`, 'success');
                    } else {
                        showToast(`Page ${pageNum} not found`, 'error');
                    }
                } else {
                    showToast(`Enter page 1-${totalPages}`, 'error');
                }
            } else {
                // Small file: Scroll to page separator
                const pageSeparator = document.querySelector(`.page-separator[data-page="${pageNum}"]`);
                if (pageSeparator) {
                    pageSeparator.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    input.value = ''; // Clear input
                    showToast(`Jumped to page ${pageNum}`, 'success');
                } else {
                    const totalPages = AppState.pages[AppState.pages.length - 1]?.pageNumber || AppState.pages.length;
                    showToast(`Page ${pageNum} not found (1-${totalPages})`, 'error');
                }
            }
        }

        function handlePageJumpKey(event) {
            if (event.key === 'Enter') {
                jumpToPage();
            }
        }

        function renderReportVirtual() {
            const display = document.getElementById('reportDisplay');

            // Determine which pages to display
            let pagesToDisplay = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                pagesToDisplay = filterPagesByRanges();
            }

            // Flatten pages into single line array
            const allLines = [];
            const pageStarts = new Map(); // Track page boundaries

            pagesToDisplay.forEach(page => {
                pageStarts.set(allLines.length, {
                    pageNumber: page.pageNumber,
                    sectionName: getSectionNameForPage(page.pageNumber)
                });

                // Store page-relative line index for each line
                page.lines.forEach((line, lineIndex) => {
                    // Store the page-relative index temporarily for rendering
                    line._pageLineIndex = lineIndex;
                    allLines.push(line);
                });
            });

            // Store for access by other functions
            AppState.flattenedLines = allLines;
            AppState.pageStarts = pageStarts;

            // Initialize or update virtual scroller
            if (!virtualScroller) {
                virtualScroller = new VirtualScroller(display, 16);
            }

            virtualScroller.init(allLines.length, (startIdx, endIdx, contentDiv) => {
                renderVisibleLines(allLines, pageStarts, startIdx, endIdx, contentDiv);
            });

            // Apply watermark once after initial render (not on every scroll)
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                setTimeout(() => applyWatermarkToDisplay(), 100);
            }

            // Cache page positions after render completes
            requestAnimationFrame(() => {
                setTimeout(() => cachePagePositions(), 100);
            });
        }

        function renderVisibleLines(allLines, pageStarts, startIdx, endIdx, contentDiv) {
            const fragment = document.createDocumentFragment();
            let currentPage = -1;

            // Add ARIA live region announcement when content changes
            contentDiv.setAttribute('aria-live', 'polite');
            contentDiv.setAttribute('aria-atomic', 'false');

            // Announce visible range to screen readers
            const announceText = `Showing lines ${startIdx + 1} to ${endIdx} of ${allLines.length}`;
            contentDiv.setAttribute('aria-label', announceText);

            for (let i = startIdx; i < endIdx; i++) {
                const line = allLines[i];

                // Add page separator if this is a page start
                if (pageStarts.has(i)) {
                    const pageInfo = pageStarts.get(i);
                    const separator = createPageSeparator(pageInfo.pageNumber, pageInfo.sectionName);
                    fragment.appendChild(separator);
                    currentPage = pageInfo.pageNumber;
                }

                // Create line element using DOM API (not string concatenation)
                const lineDiv = createLineElement(line, i);
                fragment.appendChild(lineDiv);
            }

            // Single DOM update
            contentDiv.innerHTML = '';
            contentDiv.appendChild(fragment);

            // Note: Watermark is NOT applied here during scroll updates
            // It's only applied once after initial render in renderReportVirtual()
        }

        function createLineElement(line, globalIndex) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'report-line';

            // Use the stored page-relative line index (set during flattening)
            const lineIndex = line._pageLineIndex || 0;

            // Zebra striping
            if (AppState.zebraEnabled) {
                lineDiv.classList.add(lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd');
            }

            // Data attributes
            lineDiv.dataset.line = line.lineNumber;
            lineDiv.dataset.page = line.pageNumber;
            lineDiv.dataset.pageLine = lineIndex + 1;

            // Line number
            if (AppState.showLineNumbers) {
                const lineNumSpan = document.createElement('span');
                lineNumSpan.className = 'line-number';
                lineNumSpan.textContent = lineIndex + 1;
                lineDiv.appendChild(lineNumSpan);
            }

            // Line content
            const contentSpan = document.createElement('span');
            contentSpan.className = 'line-content';

            // Apply search highlighting if match
            if (line.hasMatch && AppState.searchTerm) {
                contentSpan.innerHTML = highlightSearchTerm(escapeHtml(line.displayText));
            } else {
                contentSpan.textContent = line.displayText;
            }

            lineDiv.appendChild(contentSpan);
            return lineDiv;
        }

        function createPageSeparator(pageNumber, sectionName) {
            const separator = document.createElement('div');
            separator.className = 'page-separator';
            separator.dataset.page = pageNumber;

            const labelDiv = document.createElement('div');
            const label = document.createElement('span');
            label.className = 'page-label';
            label.textContent = sectionName
                ? `‚îÄ‚îÄ PAGE ${pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                : `‚îÄ‚îÄ PAGE ${pageNumber} ‚îÄ‚îÄ`;
            labelDiv.appendChild(label);

            const hr = document.createElement('hr');
            hr.className = 'separator-line';

            separator.appendChild(labelDiv);
            separator.appendChild(hr);

            return separator;
        }

        function highlightSearchTerm(text) {
            const caseSensitive = isCaseSensitive();
            const escapedTerm = AppState.searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');
            return text.replace(regex, '<span class="search-highlight">$&</span>');
        }

        function renderReportTraditional() {
            const display = document.getElementById('reportDisplay');

            // Hide page navigation for small files
            hidePageNavigation();

            // Determine which pages to display
            let pagesToDisplay = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                pagesToDisplay = filterPagesByRanges();
            }

            // Build report content efficiently
            let html = '<div class="report-content">';

            pagesToDisplay.forEach((page, pageIndex) => {
                // Add page separator
                const sectionName = getSectionNameForPage(page.pageNumber);
                const pageLabelText = sectionName
                    ? `‚îÄ‚îÄ PAGE ${page.pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                    : `‚îÄ‚îÄ PAGE ${page.pageNumber} ‚îÄ‚îÄ`;
                html += `<div class="page-separator" data-page="${page.pageNumber}">`;
                html += `<div><span class="page-label">${pageLabelText}</span></div>`;
                html += `<hr class="separator-line"></div>`;

                // Create page container
                html += `<div class="report-page" data-page="${page.pageNumber}" id="page-${page.pageNumber}">`;

                // Add all lines for this page
                page.lines.forEach((line, lineIndex) => {
                    const zebraClass = AppState.zebraEnabled ? (lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd') : '';
                    html += `<div class="report-line ${zebraClass}" data-line="${line.lineNumber}" data-page="${page.pageNumber}" data-page-line="${lineIndex + 1}">`;
                    if (AppState.showLineNumbers) {
                        html += `<span class="line-number">${lineIndex + 1}</span>`;
                    }
                    html += `<span class="line-content">${escapeHtml(line.displayText)}</span>`;
                    html += `</div>`;
                });

                html += '</div>';
            });

            html += '</div>';
            display.innerHTML = html;

            // Apply watermark if enabled (use setTimeout to ensure DOM is ready)
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                console.log('Scheduling watermark application in 100ms...');
                setTimeout(() => {
                    console.log('Timeout fired - calling applyWatermarkToDisplay');
                    applyWatermarkToDisplay();
                }, 100);
            } else {
                console.log('Watermark NOT scheduled - enabled:', AppState.watermark.enabled, 'imageSrc:', !!AppState.watermark.imageSrc);
            }
        }

        function buildRuler() {
            if (!AppState.showRuler) {
                return '';
            }

            const width = AppState.detectedWidth;
            let numbers = '';
            let ticks = '';

            for (let i = 1; i <= width; i++) {
                if (i % 10 === 0) {
                    // Show the full number (10, 20, 30, etc.)
                    const num = String(i);
                    // Back up and place the digits
                    const padding = num.length - 1;
                    // We need to place the digits backwards from this position
                    numbers += num.charAt(num.length - 1);
                    ticks += '|';
                } else if (i % 5 === 0) {
                    numbers += ' ';
                    ticks += '+';
                } else {
                    numbers += ' ';
                    ticks += '.';
                }
            }

            // Now build the proper number line
            let numberLine = '';
            for (let i = 1; i <= width; i++) {
                if (i % 10 === 0) {
                    const num = String(i);
                    // Place the number right-aligned at this position
                    const start = i - num.length;
                    for (let j = 0; j < num.length; j++) {
                        const pos = start + j;
                        if (pos >= 0 && pos < numberLine.length) {
                            numberLine = numberLine.substring(0, pos) + num[j] + numberLine.substring(pos + 1);
                        }
                    }
                } else {
                    if (numberLine.length < i) {
                        numberLine += ' ';
                    }
                }
            }

            // Rebuild properly
            numberLine = '';
            for (let i = 1; i <= width; i++) {
                let placed = false;

                // Check if this position is part of a decade number
                for (let decade = 10; decade <= width; decade += 10) {
                    const numStr = String(decade);
                    const startPos = decade - numStr.length + 1;
                    const endPos = decade;

                    if (i >= startPos && i <= endPos) {
                        const digitIndex = i - startPos;
                        numberLine += numStr[digitIndex];
                        placed = true;
                        break;
                    }
                }

                if (!placed) {
                    numberLine += ' ';
                }
            }

            return `<div class="ruler-numbers">${numberLine}</div><div class="ruler-ticks">${ticks}</div>`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateStickyRuler() {
            const stickyRulerContent = document.getElementById('stickyRulerContent');
            const lineToggleBtn = document.getElementById('lineToggleBtn');

            if (stickyRulerContent) {
                const rulerHTML = buildRuler();
                stickyRulerContent.innerHTML = rulerHTML;
            }

            // Update line toggle button state
            if (lineToggleBtn) {
                if (AppState.showLineNumbers) {
                    lineToggleBtn.classList.add('active');
                } else {
                    lineToggleBtn.classList.remove('active');
                }
            }

            // Align ruler with text content after a short delay for layout
            requestAnimationFrame(alignRuler);
        }

        function alignRuler() {
            const rulerContent = document.getElementById('stickyRulerContent');
            if (!rulerContent) return;

            // Find the first visible .line-content element
            const lineContent = document.querySelector('.line-content');
            if (!lineContent) return;

            const textLeft = lineContent.getBoundingClientRect().left;
            const rulerRect = rulerContent.getBoundingClientRect();

            // The ruler text currently starts at rulerRect.left + current paddingLeft
            const currentPadding = parseFloat(getComputedStyle(rulerContent).paddingLeft) || 0;
            const rulerTextStart = rulerRect.left + currentPadding;

            // Adjust padding so ruler characters align with text characters
            const adjustment = textLeft - rulerTextStart + currentPadding;
            if (Math.abs(adjustment - currentPadding) > 1) {
                rulerContent.style.paddingLeft = Math.max(0, adjustment) + 'px';
            }

            // Sync horizontal scroll: offset ruler when report is scrolled
            const reportDisplay = document.getElementById('reportDisplay');
            if (reportDisplay && reportDisplay.scrollLeft > 0) {
                rulerContent.style.transform = `translateX(-${reportDisplay.scrollLeft}px)`;
            } else {
                rulerContent.style.transform = '';
            }
        }

        function updateFileInfo() {
            document.getElementById('fileName').textContent = AppState.fileName;
            document.getElementById('fileName').classList.add('loaded');
            document.getElementById('totalPages').textContent = AppState.pages.length;
            document.getElementById('totalLines').textContent = AppState.lines.length;
            document.getElementById('fileSize').textContent = formatFileSize(AppState.fileSize);
            document.getElementById('currentPage').textContent = '1';

            // Update file type indicator
            const fileTypeIndicator = document.getElementById('fileTypeIndicator');
            if (AppState.fileType && AppState.fileType !== 'Plain') {
                fileTypeIndicator.textContent = AppState.fileType === 'Channel' ? 'CH' : 'FF';
                fileTypeIndicator.title = AppState.fileType === 'Channel' ? 'Channel Code Format' : 'Form Feed Format';
                fileTypeIndicator.classList.add('visible');
            } else {
                fileTypeIndicator.classList.remove('visible');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // ===========================
        // ZEBRA STRIPING
        // ===========================
        // Old toggleZebra function removed - using updated version that shows/hides color controls

        function updateZebraColors() {
            AppState.zebraColor1 = document.getElementById('zebraColor1').value;
            AppState.zebraColor2 = document.getElementById('zebraColor2').value;
            applyZebraColors();
            if (AppState.zebraEnabled) {
                applyZebraPattern();
            }
            saveSettings();
        }

        function applyZebraColors() {
            document.documentElement.style.setProperty('--zebra-color1', AppState.zebraColor1);
            document.documentElement.style.setProperty('--zebra-color2', AppState.zebraColor2);
        }

        function resetZebraColors() {
            AppState.zebraColor1 = '#1a1a2e';
            AppState.zebraColor2 = '#0f3460';
            document.getElementById('zebraColor1').value = AppState.zebraColor1;
            document.getElementById('zebraColor2').value = AppState.zebraColor2;
            applyZebraColors();
            if (AppState.zebraEnabled) {
                applyZebraPattern();
            }
            saveSettings();
        }

        function applyZebraPattern() {
            // Re-render to apply zebra pattern
            if (AppState.searchTerm) {
                renderReportWithSearch();
            } else {
                renderReport();
            }
        }

        // ===========================
        // MAXIMIZE/MINIMIZE VIEW
        // ===========================
        function toggleMaximize() {
            const body = document.body;
            const maximizeIcon = document.getElementById('maximizeIcon');
            const reportDisplay = document.getElementById('reportDisplay');

            if (body.classList.contains('maximized')) {
                body.classList.remove('maximized');
                maximizeIcon.textContent = '‚õ∂ Maximize';
            } else {
                body.classList.add('maximized');
                maximizeIcon.textContent = '‚õ∂ Minimize';
                // Scroll to top when maximizing to avoid empty space
                if (reportDisplay) {
                    reportDisplay.scrollTop = 0;
                }
            }
        }

        // ===========================
        // PAGE MODE
        // ===========================
        // Old changePageMode function removed - using updated version with radio buttons

        // ===========================
        // VIEW TOGGLES
        // ===========================
        // Ruler is always shown in the new design
        // toggleRuler function removed

        // Old toggleLineNumbers function removed - using updated version with # button

        // Light mode replaced with setTheme() function
        // toggleLightMode function removed

        function changeWidth() {
            const widthSelect = document.getElementById('widthSelect');
            const value = widthSelect.value;

            if (value === 'auto') {
                // Auto-detect width
                detectReportWidth();
                // Update dropdown text to show detected width
                const autoOption = widthSelect.querySelector('option[value="auto"]');
                if (autoOption) {
                    autoOption.textContent = `Auto ${AppState.detectedWidth}`;
                }
            } else {
                AppState.detectedWidth = parseInt(value);
            }

            if (AppState.lines.length > 0) {
                if (AppState.searchTerm) {
                    renderReportWithSearch();
                } else {
                    renderReport();
                }
            }
        }

        function changePagesToRender() {
            const select = document.getElementById('pagestoRenderSelect');
            PAGES_TO_RENDER = parseInt(select.value);

            // Re-render if large file is currently loaded
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                renderReport();
                showToast(`Now rendering ${PAGES_TO_RENDER} page(s) at a time`, 'success');
            }
        }

        function detectReportWidth() {
            let maxWidth = 132; // Default
            let actualMaxWidth = 0;

            AppState.lines.forEach(line => {
                const lineLength = line.displayText.length;
                if (lineLength > actualMaxWidth) {
                    actualMaxWidth = lineLength;
                }
            });

            maxWidth = actualMaxWidth;

            // Round up to nearest standard width
            if (maxWidth <= 80) {
                AppState.detectedWidth = 80;
            } else if (maxWidth <= 132) {
                AppState.detectedWidth = 132;
            } else if (maxWidth <= 198) {
                AppState.detectedWidth = 198;
            } else {
                AppState.detectedWidth = 255;
            }

            // Update select to show detected width if auto
            const widthSelect = document.getElementById('widthSelect');
            if (widthSelect && widthSelect.value === 'auto') {
                const autoOption = widthSelect.querySelector('option[value="auto"]');
                if (autoOption) {
                    autoOption.textContent = `‚ñº Auto ${AppState.detectedWidth}`;
                }
            }
        }

        function updateRangesIndicator() {
            const btn = document.getElementById('rangesBtn');
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                btn.classList.add('active-indicator');
                btn.title = `Filter active: ${AppState.pageRanges.length} range(s)`;
            } else {
                btn.classList.remove('active-indicator');
                btn.title = 'Define page ranges';
            }
        }

        // ===========================
        // SEARCH FUNCTIONALITY
        // ===========================
        // handleSearchKeyup replaced with handleSearchInput (with debouncing)
        // Old handleSearchKeyup function removed

        function performSearch() {
            const term = document.getElementById('searchBox').value.trim();
            if (!term || AppState.lines.length === 0) {
                updateSearchDisplay();
                closeSearchResultsPanel();
                return;
            }

            const caseSensitive = isCaseSensitive();
            AppState.searchTerm = term;
            AppState.searchResults = [];
            AppState.currentSearchIndex = -1;

            // Clear previous matches
            AppState.lines.forEach(line => line.hasMatch = false);

            // Escape special regex characters
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');

            // Find all matches
            AppState.lines.forEach((line, index) => {
                let match;
                const testRegex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');
                while ((match = testRegex.exec(line.displayText)) !== null) {
                    AppState.searchResults.push({
                        lineIndex: index,
                        lineNumber: line.lineNumber,
                        pageNumber: line.pageNumber,
                        matchStart: match.index,
                        matchLength: term.length
                    });
                    line.hasMatch = true;
                }
            });

            // Group results by page
            AppState.searchResultsByPage = {};
            AppState.searchResults.forEach(result => {
                const page = result.pageNumber;
                if (!AppState.searchResultsByPage[page]) {
                    AppState.searchResultsByPage[page] = [];
                }
                AppState.searchResultsByPage[page].push(result);
            });

            // Update UI
            updateSearchDisplay();
            if (AppState.searchResults.length > 0) {
                // For large files, show search results panel
                if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                    showSearchResultsPanel();
                    // Jump to first result without re-rendering all pages
                    jumpToPageWithSearchResult(AppState.searchResults[0].pageNumber, 0);
                } else {
                    // For small files, render everything with highlights
                    renderReportWithSearch();
                    jumpToSearchResult(0);
                }
            } else {
                showToast('No matches found', 'error');
                closeSearchResultsPanel();
            }
        }

        function highlightSearchResults() {
            // Re-render with search highlights
            renderReportWithSearch();
        }

        function renderReportWithSearch() {
            const display = document.getElementById('reportDisplay');

            // Determine which pages to display
            let pagesToDisplay = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                pagesToDisplay = filterPagesByRanges();
            }

            const caseSensitive = isCaseSensitive();
            const escapedTerm = AppState.searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Build report content with search highlights
            let html = '<div class="report-content">';

            pagesToDisplay.forEach((page, pageIndex) => {
                // Add page separator
                const sectionName = getSectionNameForPage(page.pageNumber);
                const pageLabelText = sectionName
                    ? `‚îÄ‚îÄ PAGE ${page.pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                    : `‚îÄ‚îÄ PAGE ${page.pageNumber} ‚îÄ‚îÄ`;
                html += `<div class="page-separator" data-page="${page.pageNumber}">`;
                html += `<div><span class="page-label">${pageLabelText}</span></div>`;
                html += `<hr class="separator-line"></div>`;

                // Create page container
                html += `<div class="report-page" data-page="${page.pageNumber}" id="page-${page.pageNumber}">`;

                // Add all lines for this page
                page.lines.forEach((line, lineIndex) => {
                    let lineText = escapeHtml(line.displayText);

                    // Apply search highlighting if this line has a match
                    if (line.hasMatch && AppState.searchTerm) {
                        // Create new regex for each line to avoid lastIndex issues
                        const regex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');
                        lineText = lineText.replace(regex, '<span class="search-highlight">$&</span>');
                    }

                    const zebraClass = AppState.zebraEnabled ? (lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd') : '';
                    html += `<div class="report-line ${zebraClass}" data-line="${line.lineNumber}">`;
                    if (AppState.showLineNumbers) {
                        html += `<span class="line-number">${line.lineNumber}</span>`;
                    }
                    html += `<span class="line-content">${lineText}</span>`;
                    html += `</div>`;
                });

                html += '</div>';
            });

            html += '</div>';
            display.innerHTML = html;

            // Apply watermark if enabled (use setTimeout to ensure DOM is ready)
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                console.log('Scheduling watermark application in 100ms...');
                setTimeout(() => {
                    console.log('Timeout fired - calling applyWatermarkToDisplay');
                    applyWatermarkToDisplay();
                }, 100);
            } else {
                console.log('Watermark NOT scheduled - enabled:', AppState.watermark.enabled, 'imageSrc:', !!AppState.watermark.imageSrc);
            }

            // Update ranges button indicator
            updateRangesIndicator();

            // Update sticky ruler bar
            updateStickyRuler();
        }

        function jumpToSearchResult(index) {
            if (AppState.searchResults.length === 0) return;

            AppState.currentSearchIndex = index;
            const result = AppState.searchResults[index];

            if (virtualScroller && AppState.flattenedLines) {
                // Virtual scrolling: calculate flat index and scroll to it
                const lineIndex = result.lineIndex;

                // Scroll to line using virtual scroller
                virtualScroller.scrollToIndex(lineIndex);

                // Wait for render, then highlight
                setTimeout(() => {
                    const lineElement = document.querySelector(`[data-line="${result.lineNumber}"]`);
                    if (lineElement) {
                        // Update current highlight
                        const highlights = document.querySelectorAll('.search-highlight');
                        highlights.forEach(h => h.classList.remove('current'));

                        const highlight = lineElement.querySelectorAll('.search-highlight')[0];
                        if (highlight) {
                            highlight.classList.add('current');
                        }
                        lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            } else {
                // Traditional rendering: direct scroll
                const lineElement = document.querySelector(`[data-line="${result.lineNumber}"]`);
                if (lineElement) {
                    // Update current highlight
                    const highlights = document.querySelectorAll('.search-highlight');
                    highlights.forEach(h => h.classList.remove('current'));

                    const highlight = lineElement.querySelectorAll('.search-highlight')[0];
                    if (highlight) {
                        highlight.classList.add('current');
                    }
                    lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            // Update search display
            updateSearchDisplay();
        }

        function nextSearchResult() {
            if (AppState.searchResults.length === 0) return;
            const nextIndex = (AppState.currentSearchIndex + 1) % AppState.searchResults.length;

            // For large files, check if we need to jump to a different page
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                const nextResult = AppState.searchResults[nextIndex];
                const currentRenderedPages = getCurrentRenderedPageNumbers();

                if (!currentRenderedPages.includes(nextResult.pageNumber)) {
                    // Need to jump to a different page
                    jumpToPageWithSearchResult(nextResult.pageNumber, 0);
                } else {
                    // Result is on current pages, just navigate
                    jumpToSearchResult(nextIndex);
                }
            } else {
                jumpToSearchResult(nextIndex);
            }
        }

        function previousSearchResult() {
            if (AppState.searchResults.length === 0) return;
            const prevIndex = (AppState.currentSearchIndex - 1 + AppState.searchResults.length) % AppState.searchResults.length;

            // For large files, check if we need to jump to a different page
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                const prevResult = AppState.searchResults[prevIndex];
                const currentRenderedPages = getCurrentRenderedPageNumbers();

                if (!currentRenderedPages.includes(prevResult.pageNumber)) {
                    // Need to jump to a different page
                    jumpToPageWithSearchResult(prevResult.pageNumber, 0);
                } else {
                    // Result is on current pages, just navigate
                    jumpToSearchResult(prevIndex);
                }
            } else {
                jumpToSearchResult(prevIndex);
            }
        }

        function getCurrentRenderedPageNumbers() {
            const pageElements = document.querySelectorAll('.report-page[data-page]');
            const pageNumbers = [];
            pageElements.forEach(el => {
                const pageNum = parseInt(el.getAttribute('data-page'));
                if (!isNaN(pageNum)) {
                    pageNumbers.push(pageNum);
                }
            });
            return pageNumbers;
        }

        function clearSearch() {
            document.getElementById('searchBox').value = '';
            document.getElementById('clearSearchBtn').classList.remove('visible');
            AppState.searchTerm = '';
            AppState.searchResults = [];
            AppState.searchResultsByPage = {};
            AppState.currentSearchIndex = -1;

            // Clear hasMatch flags
            AppState.lines.forEach(line => line.hasMatch = false);

            // Update display
            updateSearchDisplay();
            closeSearchResultsPanel();

            // Re-render without search highlights
            renderReport();
        }

        // ===========================
        // SEARCH RESULTS PANEL
        // ===========================
        function showSearchResultsPanel() {
            const panel = document.getElementById('searchResultsPanel');
            const content = document.getElementById('searchResultsContent');
            const title = document.getElementById('searchResultsPanelTitle');

            const totalMatches = AppState.searchResults.length;
            const totalPages = Object.keys(AppState.searchResultsByPage).length;

            title.textContent = `${totalMatches} matches on ${totalPages} pages`;

            // Build list of pages with matches
            let html = '';
            const sortedPages = Object.keys(AppState.searchResultsByPage).map(Number).sort((a, b) => a - b);

            sortedPages.forEach(pageNum => {
                const matches = AppState.searchResultsByPage[pageNum].length;
                html += `<div class="search-result-page" onclick="jumpToPageWithSearchResult(${pageNum}, 0)">`;
                html += `  <div class="search-result-page-number">Page ${pageNum}</div>`;
                html += `  <div class="search-result-match-count">${matches} match${matches > 1 ? 'es' : ''}</div>`;
                html += `</div>`;
            });

            content.innerHTML = html;
            panel.classList.add('active');
        }

        function closeSearchResultsPanel() {
            document.getElementById('searchResultsPanel').classList.remove('active');
        }

        function toggleSearchResultsPanel() {
            const panel = document.getElementById('searchResultsPanel');
            panel.classList.toggle('active');
        }

        function jumpToPageWithSearchResult(pageNum, resultIndexInPage) {
            // For large files: jump to specific page and render with search highlights
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                // Find page index in AppState.pages
                const pageIndex = AppState.pages.findIndex(p => p.pageNumber === pageNum);
                if (pageIndex >= 0) {
                    AppState.currentPageIndex = pageIndex;
                    renderPageByPageWithSearch();

                    // Find the search result index for this page and position
                    const resultsOnPage = AppState.searchResultsByPage[pageNum] || [];
                    if (resultsOnPage.length > 0) {
                        const targetResult = resultsOnPage[resultIndexInPage] || resultsOnPage[0];
                        const globalIndex = AppState.searchResults.findIndex(r =>
                            r.lineNumber === targetResult.lineNumber &&
                            r.matchStart === targetResult.matchStart
                        );
                        if (globalIndex >= 0) {
                            AppState.currentSearchIndex = globalIndex;

                            // Scroll to the line
                            setTimeout(() => {
                                const lineElement = document.querySelector(`[data-line="${targetResult.lineNumber}"]`);
                                if (lineElement) {
                                    lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                                    // Highlight current match
                                    const highlights = document.querySelectorAll('.search-highlight');
                                    highlights.forEach(h => h.classList.remove('current'));
                                    const highlight = lineElement.querySelectorAll('.search-highlight')[0];
                                    if (highlight) {
                                        highlight.classList.add('current');
                                    }
                                }
                            }, 100);
                        }
                    }

                    updateSearchDisplay();
                }
            } else {
                // For small files: just scroll to the match
                const resultsOnPage = AppState.searchResultsByPage[pageNum] || [];
                if (resultsOnPage.length > 0) {
                    const targetResult = resultsOnPage[resultIndexInPage] || resultsOnPage[0];
                    const globalIndex = AppState.searchResults.findIndex(r =>
                        r.lineNumber === targetResult.lineNumber &&
                        r.matchStart === targetResult.matchStart
                    );
                    if (globalIndex >= 0) {
                        jumpToSearchResult(globalIndex);
                    }
                }
            }
        }

        function renderPageByPageWithSearch() {
            const display = document.getElementById('reportDisplay');

            // Initialize current page index if not set
            if (!AppState.currentPageIndex) {
                AppState.currentPageIndex = 0;
            }

            // Determine which pages to display
            let allPages = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                allPages = filterPagesByRanges();
            }

            // Calculate page range to render (current page +/- buffer)
            const startPage = Math.max(0, AppState.currentPageIndex - Math.floor(PAGES_TO_RENDER / 2));
            const endPage = Math.min(allPages.length, startPage + PAGES_TO_RENDER);
            const pagesToDisplay = allPages.slice(startPage, endPage);

            // Get actual page numbers being displayed
            const firstVisiblePage = pagesToDisplay[0]?.pageNumber || 1;
            const lastVisiblePage = pagesToDisplay[pagesToDisplay.length - 1]?.pageNumber || 1;
            const totalPages = allPages[allPages.length - 1]?.pageNumber || allPages.length;

            // Show navigation controls
            showPageNavigation(firstVisiblePage, lastVisiblePage, totalPages, AppState.currentPageIndex, allPages.length);

            // Render pages with search highlights
            const caseSensitive = isCaseSensitive();
            const escapedTerm = AppState.searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            let html = '<div class="report-content">';

            pagesToDisplay.forEach((page, pageIndex) => {
                // Add page separator
                const sectionName = getSectionNameForPage(page.pageNumber);
                const pageLabelText = sectionName
                    ? `‚îÄ‚îÄ PAGE ${page.pageNumber} (${sectionName}) ‚îÄ‚îÄ`
                    : `‚îÄ‚îÄ PAGE ${page.pageNumber} ‚îÄ‚îÄ`;
                html += `<div class="page-separator" data-page="${page.pageNumber}">`;
                html += `<div><span class="page-label">${pageLabelText}</span></div>`;
                html += `<hr class="separator-line"></div>`;

                // Create page container
                html += `<div class="report-page" data-page="${page.pageNumber}" id="page-${page.pageNumber}">`;

                // Add all lines for this page
                page.lines.forEach((line, lineIndex) => {
                    let lineText = escapeHtml(line.displayText);

                    // Apply search highlighting if this line has a match
                    if (line.hasMatch && AppState.searchTerm) {
                        const regex = new RegExp(escapedTerm, caseSensitive ? 'g' : 'gi');
                        lineText = lineText.replace(regex, '<span class="search-highlight">$&</span>');
                    }

                    const zebraClass = AppState.zebraEnabled ? (lineIndex % 2 === 0 ? 'zebra-even' : 'zebra-odd') : '';
                    html += `<div class="report-line ${zebraClass}" data-line="${line.lineNumber}" data-page="${page.pageNumber}" data-page-line="${lineIndex + 1}">`;
                    if (AppState.showLineNumbers) {
                        html += `<span class="line-number">${lineIndex + 1}</span>`;
                    }
                    html += `<span class="line-content">${lineText}</span>`;
                    html += `</div>`;
                });

                html += '</div>';
            });

            html += '</div>';
            display.innerHTML = html;

            // Apply watermark if enabled
            if (AppState.watermark.enabled && AppState.watermark.imageSrc) {
                setTimeout(() => applyWatermarkToDisplay(), 100);
            }

            // Update current page indicator in footer to match navigation bar
            if (firstVisiblePage === lastVisiblePage) {
                AppState.currentPage = firstVisiblePage;
                document.getElementById('currentPage').textContent = firstVisiblePage;
            } else {
                AppState.currentPage = lastVisiblePage;
                document.getElementById('currentPage').textContent = `${firstVisiblePage}-${lastVisiblePage}`;
            }
        }

        // ===========================
        // PAGE NAVIGATION
        // ===========================
        // REMOVED DUPLICATE: handlePageJumpKeyup and jumpToPage functions
        // These are already defined correctly earlier in the file (around line 2910-2955)

        // ===========================
        // PAGE RANGES
        // ===========================
        function openRangesModal() {
            if (AppState.pages.length === 0) {
                showToast('Please load a file first', 'error');
                return;
            }
            renderRangesTable();
            document.getElementById('showRangesOnly').checked = AppState.showRangesOnly;
            document.getElementById('rangesModal').classList.add('active');
        }

        function closeRangesModal() {
            document.getElementById('rangesModal').classList.remove('active');
        }

        function renderRangesTable() {
            const tbody = document.getElementById('rangesTableBody');
            tbody.innerHTML = '';

            if (AppState.pageRanges.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">No ranges defined</td></tr>';
                return;
            }

            AppState.pageRanges.forEach((range, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><input type="text" class="range-input" value="${range.name}" onchange="updateRangeName(${index}, this.value)"></td>
                    <td><input type="number" class="range-input" value="${range.startPage}" min="1" max="${AppState.pages.length}" onchange="updateRangeStart(${index}, this.value)"></td>
                    <td><input type="number" class="range-input" value="${range.pageCount}" min="1" onchange="updateRangeCount(${index}, this.value)"></td>
                    <td><button class="btn btn-small" onclick="deleteRange(${index})">Delete</button></td>
                `;
                tbody.appendChild(row);
            });
        }

        function addNewRange() {
            const newRange = {
                id: Date.now(),
                name: `Section ${AppState.pageRanges.length + 1}`,
                startPage: 1,
                pageCount: 1
            };
            AppState.pageRanges.push(newRange);
            renderRangesTable();
            if (AppState.showRangesOnly && AppState.lines.length > 0) {
                renderReport();
            }
            updateRangesIndicator();
        }

        function updateRangeName(index, name) {
            AppState.pageRanges[index].name = name;
            if (AppState.showRangesOnly && AppState.lines.length > 0) {
                renderReport();
            }
        }

        function updateRangeStart(index, value) {
            const startPage = parseInt(value);
            if (startPage >= 1 && startPage <= AppState.pages.length) {
                AppState.pageRanges[index].startPage = startPage;
                if (AppState.showRangesOnly && AppState.lines.length > 0) {
                    renderReport();
                }
            }
        }

        function updateRangeCount(index, value) {
            const count = parseInt(value);
            if (count >= 1) {
                AppState.pageRanges[index].pageCount = count;
                if (AppState.showRangesOnly && AppState.lines.length > 0) {
                    renderReport();
                }
            }
        }

        function deleteRange(index) {
            AppState.pageRanges.splice(index, 1);
            renderRangesTable();
            if (AppState.showRangesOnly && AppState.lines.length > 0) {
                renderReport();
            }
            updateRangesIndicator();
        }

        function toggleRangesFilter() {
            AppState.showRangesOnly = document.getElementById('showRangesOnly').checked;
            if (AppState.lines.length > 0) {
                renderReport();
                if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                    showToast('Showing selected ranges only', 'success');
                } else {
                    showToast('Showing all pages', 'success');
                }
            }
            updateRangesIndicator();
        }

        // ===========================
        // WATERMARK
        // ===========================
        function openWatermarkModal() {
            document.getElementById('watermarkModal').classList.add('active');
            setupWatermarkDragDrop();
            updateWatermarkPreview();
        }

        function closeWatermarkModal() {
            document.getElementById('watermarkModal').classList.remove('active');
            // Re-render if watermark settings changed
            if (AppState.lines.length > 0 && AppState.watermark.enabled) {
                if (AppState.searchTerm) {
                    renderReportWithSearch();
                } else {
                    renderReport();
                }
            }
        }

        function setupWatermarkDragDrop() {
            const uploadArea = document.getElementById('watermarkUploadArea');

            uploadArea.ondragover = (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            };

            uploadArea.ondragleave = () => {
                uploadArea.classList.remove('dragover');
            };

            uploadArea.ondrop = (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadWatermarkImage(file);
                }
            };
        }

        function handleWatermarkUpload(event) {
            const file = event.target.files[0];
            if (file) {
                loadWatermarkImage(file);
            }
        }

        function loadWatermarkImage(file) {
            if (file.size > 5 * 1024 * 1024) {
                showToast('Image too large (max 5MB)', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Scale down large images to fit page better
                    const maxDimension = 400; // Max width or height in pixels
                    let scaledImg = img;

                    if (img.width > maxDimension || img.height > maxDimension) {
                        // Create a scaled version
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        let scale = 1;
                        if (img.width > img.height) {
                            scale = maxDimension / img.width;
                        } else {
                            scale = maxDimension / img.height;
                        }

                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;

                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        // Create new image from scaled canvas
                        scaledImg = new Image();
                        scaledImg.onload = () => {
                            AppState.watermark.imageData = scaledImg;
                            AppState.watermark.imageSrc = canvas.toDataURL();
                            updateWatermarkPreview();
                            showToast(`Watermark loaded (scaled to ${Math.round(canvas.width)}x${Math.round(canvas.height)})`, 'success');
                        };
                        scaledImg.src = canvas.toDataURL();
                    } else {
                        AppState.watermark.imageData = img;
                        AppState.watermark.imageSrc = e.target.result;
                        updateWatermarkPreview();
                        showToast('Watermark image loaded', 'success');
                    }
                };
                img.onerror = () => {
                    showToast('Error loading image', 'error');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setWatermarkPosition(position) {
            AppState.watermark.position = position;

            // Update button styles
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-position="${position}"]`).classList.add('active');

            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateRotation(value) {
            AppState.watermark.rotation = parseInt(value);
            document.getElementById('rotationValue').textContent = value + '¬∞';
            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateOpacity(value) {
            AppState.watermark.opacity = parseInt(value);
            document.getElementById('opacityValue').textContent = value + '%';
            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateScale(value) {
            AppState.watermark.scale = parseInt(value);
            document.getElementById('scaleValue').textContent = (value / 100).toFixed(1) + 'x';
            updateWatermarkPreview();
            updateLiveWatermark();
        }

        function updateLiveWatermark() {
            // Update watermark in real-time if enabled and content is loaded
            if (AppState.watermark.enabled && AppState.lines.length > 0 && AppState.watermark.imageData) {
                applyWatermarkToDisplay();
            }
        }

        function toggleWatermark() {
            AppState.watermark.enabled = document.getElementById('watermarkEnabled').checked;
            if (AppState.watermark.enabled && !AppState.watermark.imageData) {
                showToast('Please upload a watermark image first', 'error');
                document.getElementById('watermarkEnabled').checked = false;
                AppState.watermark.enabled = false;
                return;
            }
            if (AppState.lines.length > 0) {
                renderReport();
            }
        }

        function applyWatermarkToDisplay() {
            console.log('=== applyWatermarkToDisplay called ===');
            console.log('Watermark enabled:', AppState.watermark.enabled);
            console.log('Watermark imageSrc:', AppState.watermark.imageSrc ? 'exists' : 'null');
            console.log('Watermark imageData:', AppState.watermark.imageData);

            if (!AppState.watermark.enabled || !AppState.watermark.imageSrc) {
                console.log('Watermark not enabled or no image source - exiting');
                return;
            }

            if (!AppState.watermark.imageData) {
                console.error('Watermark imageData not loaded');
                return;
            }

            const opacity = AppState.watermark.opacity / 100;
            const scale = AppState.watermark.scale / 100;
            const rotation = AppState.watermark.rotation;

            console.log('Watermark settings:', { opacity, scale, rotation, position: AppState.watermark.position });

            // Apply to all page elements
            const pages = document.querySelectorAll('.report-page');

            console.log('Found pages:', pages.length);

            if (pages.length === 0) {
                console.warn('No report pages found for watermark application');
                return;
            }

            pages.forEach((pageEl, index) => {
                try {
                    console.log(`Processing page ${index + 1}`);

                    // Use actual page element dimensions for accurate positioning
                    const pageRect = pageEl.getBoundingClientRect();
                    const pageWidth = pageEl.offsetWidth;
                    const pageHeight = pageEl.offsetHeight;

                    console.log(`  Page dimensions: ${pageWidth}x${pageHeight}`);

                    // Count lines and calculate line-based positioning
                    const lineElements = pageEl.querySelectorAll('.report-line');
                    const lineCount = lineElements.length;
                    console.log(`  Line count: ${lineCount}`);

                    // Create watermark canvas sized to actual page
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = Math.max(pageWidth, 100);
                    canvas.height = Math.max(pageHeight, 400);

                // Calculate position within content area
                const positions = {
                    'top-left': { x: 0.15, y: 0.15 },
                    'top-center': { x: 0.5, y: 0.15 },
                    'top-right': { x: 0.85, y: 0.15 },
                    'middle-left': { x: 0.15, y: 0.5 },
                    'center': { x: 0.5, y: 0.5 },
                    'middle-right': { x: 0.85, y: 0.5 },
                    'bottom-left': { x: 0.15, y: 0.85 },
                    'bottom-center': { x: 0.5, y: 0.85 },
                    'bottom-right': { x: 0.85, y: 0.85 }
                };

                const pos = positions[AppState.watermark.position] || positions['center'];

                // For middle/center positions, calculate based on actual line positions
                let yPos = pos.y;
                if (lineCount > 0 && (AppState.watermark.position.includes('middle') || AppState.watermark.position === 'center')) {
                    const firstLine = lineElements[0];
                    const lastLine = lineElements[lineCount - 1];
                    if (firstLine && lastLine) {
                        const firstLineTop = firstLine.offsetTop;
                        const lastLineTop = lastLine.offsetTop;
                        const lastLineBottom = lastLineTop + lastLine.offsetHeight;

                        // Middle of content is between first line top and last line bottom
                        const contentMiddle = (firstLineTop + lastLineBottom) / 2;
                        yPos = contentMiddle / pageHeight;

                        console.log(`  Line-based center: firstLine=${firstLineTop}px, lastLine=${lastLineBottom}px, middle=${contentMiddle}px, ratio=${yPos.toFixed(3)}`);
                    }
                }

                const x = canvas.width * pos.x;
                const y = canvas.height * yPos;

                console.log(`  Position: ${AppState.watermark.position} at (${x}, ${y})`);

                // Draw watermark
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.translate(x, y);
                ctx.rotate(rotation * Math.PI / 180);

                const imgWidth = AppState.watermark.imageData.width * scale;
                const imgHeight = AppState.watermark.imageData.height * scale;

                console.log(`  Image size: ${imgWidth}x${imgHeight}`);

                ctx.drawImage(
                    AppState.watermark.imageData,
                    -imgWidth / 2,
                    -imgHeight / 2,
                    imgWidth,
                    imgHeight
                );
                ctx.restore();

                    // Apply watermark to page using CSS custom properties
                    const dataUrl = canvas.toDataURL();
                    console.log(`  Data URL length: ${dataUrl.length}`);

                    pageEl.style.setProperty('--watermark-image', `url(${dataUrl})`);
                    pageEl.style.setProperty('--watermark-position', 'left top');
                    pageEl.style.setProperty('--watermark-size', `${canvas.width}px ${canvas.height}px`);

                    console.log(`  Applied to page - CSS properties set`);
                } catch (error) {
                    console.error('Error applying watermark to page:', error);
                }
            });
            console.log('=== Watermark application complete ===');
        }

        function updateWatermarkPreview() {
            const preview = document.getElementById('watermarkPreview');

            if (!AppState.watermark.imageData) {
                preview.innerHTML = `
                    <div style="color: var(--text-secondary); text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">üñºÔ∏è</div>
                        <div>Upload an image to preview</div>
                    </div>
                `;
                return;
            }

            // Create preview with watermark
            preview.innerHTML = '';
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Use preview pane dimensions
            const previewWidth = preview.offsetWidth || 400;
            const previewHeight = preview.offsetHeight || 300;

            canvas.width = previewWidth;
            canvas.height = previewHeight;

            // Fill background to simulate report
            ctx.fillStyle = AppState.theme === 'light' ? '#ffffff' : (AppState.theme === 'high-contrast' ? '#000000' : '#0a0a0a');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sample text at readable size (don't scale down)
            ctx.fillStyle = AppState.theme === 'light' ? '#000000' : (AppState.theme === 'high-contrast' ? '#00ff00' : '#e0e0e0');
            ctx.font = '9px Courier New';
            const sampleLines = [
                'REPORT NO - SAMPLE          PREVIEW OF WATERMARK PLACEMENT',
                'ACCOUNT  NAME           AMOUNT      DATE       STATUS',
                '12345    JOHN DOE        1,234.56    01/27/26   ACTIVE',
                '67890    JANE SMITH      5,678.90    01/27/26   ACTIVE',
                '11111    BOB JOHNSON     9,012.34    01/27/26   PENDING',
                '22222    ALICE BROWN     3,456.78    01/27/26   ACTIVE'
            ];

            const lineHeight = 11;
            const startY = 20;
            for (let i = 0; i < sampleLines.length; i++) {
                ctx.fillText(sampleLines[i], 10, startY + i * lineHeight);
            }

            // Continue pattern
            for (let i = sampleLines.length; i < Math.floor((canvas.height - startY) / lineHeight); i++) {
                const lineIndex = i % sampleLines.length;
                ctx.fillText(sampleLines[lineIndex], 10, startY + i * lineHeight);
            }

            // Calculate position for watermark
            const positions = {
                'top-left': { x: 0.15, y: 0.15 },
                'top-center': { x: 0.5, y: 0.15 },
                'top-right': { x: 0.85, y: 0.15 },
                'middle-left': { x: 0.15, y: 0.5 },
                'center': { x: 0.5, y: 0.5 },
                'middle-right': { x: 0.85, y: 0.5 },
                'bottom-left': { x: 0.15, y: 0.85 },
                'bottom-center': { x: 0.5, y: 0.85 },
                'bottom-right': { x: 0.85, y: 0.85 }
            };

            const pos = positions[AppState.watermark.position] || positions['center'];
            const x = canvas.width * pos.x;
            const y = canvas.height * pos.y;

            // Draw watermark at preview scale
            ctx.save();
            ctx.globalAlpha = AppState.watermark.opacity / 100;
            ctx.translate(x, y);
            ctx.rotate(AppState.watermark.rotation * Math.PI / 180);

            const userScale = AppState.watermark.scale / 100;
            // Show watermark at a reasonable preview size (0.5x of actual for preview)
            const previewScale = 0.5;
            const imgWidth = AppState.watermark.imageData.width * userScale * previewScale;
            const imgHeight = AppState.watermark.imageData.height * userScale * previewScale;

            ctx.drawImage(
                AppState.watermark.imageData,
                -imgWidth / 2,
                -imgHeight / 2,
                imgWidth,
                imgHeight
            );
            ctx.restore();

            preview.appendChild(canvas);
        }

        // ===========================
        // PDF EXPORT
        // ===========================
        async function exportToPDF() {
            if (AppState.pages.length === 0) {
                showToast('Please load a file first', 'error');
                return;
            }

            if (typeof window.jspdf === 'undefined') {
                showToast('PDF library not loaded. Please refresh the page.', 'error');
                return;
            }

            try {
                AppState.pdfExportCancelled = false;
                showProgress('Preparing PDF export...', 0);
                document.getElementById('progressCancel').style.display = '';

                const { jsPDF } = window.jspdf;

                // Page dimensions based on selected page size (all landscape, in points)
                const pageSizes = {
                    greenbar: { w: 14.875 * 72, h: 11 * 72 },     // 1071 √ó 792pt
                    letter:   { w: 11 * 72,     h: 8.5 * 72 },    // 792 √ó 612pt
                    a4:       { w: 841.89,      h: 595.28 },       // 297 √ó 210mm
                    a3:       { w: 1190.55,     h: 841.89 }        // 420 √ó 297mm
                };
                const pgSize = pageSizes[AppState.pdfPageSize] || pageSizes.greenbar;
                const pageWidthPt = pgSize.w;
                const pageHeightPt = pgSize.h;
                const marginPt = 36;               // 0.5" margins

                const usableWidth = pageWidthPt - 2 * marginPt;
                const usableHeight = pageHeightPt - 2 * marginPt;

                // Font sizing: scale down for wider reports
                const columns = AppState.detectedWidth || 132;
                // Base: 10pt Courier fits ~166 chars in 999pt (charWidth ‚âà 6pt)
                // Scale down proportionally for wider reports, minimum 6pt
                let fontSize = 10;
                if (columns > 166) {
                    fontSize = Math.max(6, (usableWidth / columns) / 0.6);
                }
                const charWidth = fontSize * 0.6;
                const lineHeight = fontSize * 1.2;

                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'pt',
                    format: [pageWidthPt, pageHeightPt]
                });

                pdf.setProperties({
                    title: AppState.fileName,
                    creator: 'RPT_Viewer',
                    producer: 'jsPDF 2.5.1'
                });

                // Determine which pages to export
                let pagesToExport = AppState.pages;
                if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                    pagesToExport = filterPagesByRanges();
                }

                const totalPages = pagesToExport.length;

                // Pre-render watermark overlay if needed
                let watermarkDataUrl = null;
                if (AppState.watermark.enabled && AppState.watermark.imageData) {
                    watermarkDataUrl = renderWatermarkForPdf(pageWidthPt, pageHeightPt);
                }

                for (let i = 0; i < totalPages; i++) {
                    // Check for cancellation
                    if (AppState.pdfExportCancelled) {
                        hideProgress();
                        showToast('PDF export cancelled', 'info');
                        return;
                    }

                    const page = pagesToExport[i];
                    updateProgress(((i + 1) / totalPages) * 100, `Exporting page ${i + 1} of ${totalPages}...`);

                    if (i > 0) pdf.addPage();

                    // Set font: Courier is built into jsPDF
                    pdf.setFont('Courier', 'normal');
                    pdf.setFontSize(fontSize);
                    pdf.setTextColor(0, 0, 0);

                    // Resolve zebra colors based on current theme
                    let zebraHex1, zebraHex2;
                    if (AppState.pdfZebraEnabled) {
                        if (AppState.theme === 'light') {
                            zebraHex1 = '#f5f5f5';
                            zebraHex2 = '#ffffff';
                        } else {
                            zebraHex1 = AppState.zebraColor1;
                            zebraHex2 = AppState.zebraColor2;
                        }
                    }

                    // Render each line as native text
                    let yPos = marginPt + lineHeight;
                    for (let li = 0; li < page.lines.length; li++) {
                        const line = page.lines[li];
                        // Zebra striping background
                        if (AppState.pdfZebraEnabled) {
                            const hex = (li % 2 === 0) ? zebraHex1 : zebraHex2;
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            pdf.setFillColor(r, g, b);
                            pdf.rect(marginPt, yPos - lineHeight + 2, usableWidth, lineHeight, 'F');
                            pdf.setTextColor(0, 0, 0);
                        }
                        const text = line.displayText || '';
                        pdf.text(text, marginPt, yPos);
                        yPos += lineHeight;
                    }

                    // Overlay watermark if enabled
                    if (watermarkDataUrl) {
                        pdf.addImage(watermarkDataUrl, 'PNG', 0, 0, pageWidthPt, pageHeightPt);
                    }

                    // Yield to event loop so cancel button and progress bar work
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Final cancellation check before save
                if (AppState.pdfExportCancelled) {
                    hideProgress();
                    showToast('PDF export cancelled', 'info');
                    return;
                }

                const fileName = `${AppState.fileName.replace('.txt', '').replace('.TXT', '')}_export_${Date.now()}.pdf`;
                pdf.save(fileName);

                hideProgress();
                showToast('PDF exported successfully!', 'success');
            } catch (error) {
                hideProgress();
                showToast('Error exporting PDF: ' + error.message, 'error');
                console.error('PDF export error:', error);
            }
        }

        function renderWatermarkForPdf(pageWidthPt, pageHeightPt) {
            // Render watermark to a canvas matching PDF page dimensions, return as PNG data URL
            const scale = 2; // render at 2x for clarity
            const canvas = document.createElement('canvas');
            canvas.width = pageWidthPt * scale;
            canvas.height = pageHeightPt * scale;
            const ctx = canvas.getContext('2d');

            // Position map (same as display watermark)
            const positions = {
                'top-left': { x: 0.15, y: 0.15 },
                'top-center': { x: 0.5, y: 0.15 },
                'top-right': { x: 0.85, y: 0.15 },
                'middle-left': { x: 0.15, y: 0.5 },
                'center': { x: 0.5, y: 0.5 },
                'middle-right': { x: 0.85, y: 0.5 },
                'bottom-left': { x: 0.15, y: 0.85 },
                'bottom-center': { x: 0.5, y: 0.85 },
                'bottom-right': { x: 0.85, y: 0.85 }
            };

            const pos = positions[AppState.watermark.position] || positions['center'];
            const x = canvas.width * pos.x;
            const y = canvas.height * pos.y;

            ctx.save();
            ctx.globalAlpha = AppState.watermark.opacity / 100;
            ctx.translate(x, y);
            ctx.rotate(AppState.watermark.rotation * Math.PI / 180);

            const wmScale = (AppState.watermark.scale / 100) * scale;
            const imgWidth = AppState.watermark.imageData.width * wmScale;
            const imgHeight = AppState.watermark.imageData.height * wmScale;

            ctx.drawImage(
                AppState.watermark.imageData,
                -imgWidth / 2,
                -imgHeight / 2,
                imgWidth,
                imgHeight
            );
            ctx.restore();

            return canvas.toDataURL('image/png');
        }

        function filterPagesByRanges() {
            const filteredPages = [];
            AppState.pageRanges.forEach(range => {
                for (let i = 0; i < range.pageCount; i++) {
                    const pageNum = range.startPage + i;
                    const page = AppState.pages.find(p => p.pageNumber === pageNum);
                    if (page) {
                        filteredPages.push(page);
                    }
                }
            });
            return filteredPages;
        }

        function getSectionNameForPage(pageNumber) {
            if (!AppState.showRangesOnly || AppState.pageRanges.length === 0) {
                return null;
            }

            for (const range of AppState.pageRanges) {
                const endPage = range.startPage + range.pageCount - 1;
                if (pageNumber >= range.startPage && pageNumber <= endPage) {
                    return range.name;
                }
            }
            return null;
        }

        // ===========================
        // DRAG AND DROP
        // ===========================
        function setupDragAndDrop() {
            const dropZone = document.getElementById('reportDisplay');

            dropZone.ondragover = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            dropZone.ondrop = (e) => {
                e.preventDefault();
                e.stopPropagation();

                const file = e.dataTransfer.files[0];
                if (file && (file.name.endsWith('.txt') || file.name.endsWith('.TXT'))) {
                    loadFile(file);
                } else {
                    showToast('Please drop a .TXT file', 'error');
                }
            };
        }

        // ===========================
        // KEYBOARD SHORTCUTS
        // ===========================
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+O: Open file
                if (e.ctrlKey && e.key === 'o') {
                    e.preventDefault();
                    document.getElementById('fileInput').click();
                }

                // Ctrl+F: Focus search
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    document.getElementById('searchBox').focus();
                }

                // Ctrl+G: Jump to page
                if (e.ctrlKey && e.key === 'g') {
                    e.preventDefault();
                    document.getElementById('pageJumpInput').focus();
                    document.getElementById('pageJumpInput').select();
                }

                // Ctrl+E: Export PDF
                if (e.ctrlKey && e.key === 'e') {
                    e.preventDefault();
                    exportToPDF();
                }

                // Ctrl+W: Toggle watermark modal
                if (e.ctrlKey && e.key === 'w') {
                    e.preventDefault();
                    openWatermarkModal();
                }

                // Ctrl+Z: Toggle zebra
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    const toggle = document.getElementById('zebraToggle');
                    toggle.checked = !toggle.checked;
                    toggleZebra();
                }

                // Ctrl+ (Plus/Equal): Zoom in
                if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                    e.preventDefault();
                    const currentZoom = AppState.zoomLevel;
                    const zoomLevels = [50, 75, 100, 125, 150, 200];
                    const currentIndex = zoomLevels.indexOf(currentZoom);
                    if (currentIndex < zoomLevels.length - 1) {
                        setZoomLevel(zoomLevels[currentIndex + 1].toString());
                    }
                }

                // Ctrl- (Minus): Zoom out
                if (e.ctrlKey && e.key === '-') {
                    e.preventDefault();
                    const currentZoom = AppState.zoomLevel;
                    const zoomLevels = [50, 75, 100, 125, 150, 200];
                    const currentIndex = zoomLevels.indexOf(currentZoom);
                    if (currentIndex > 0) {
                        setZoomLevel(zoomLevels[currentIndex - 1].toString());
                    }
                }

                // Ctrl+0: Reset zoom
                if (e.ctrlKey && e.key === '0') {
                    e.preventDefault();
                    setZoomLevel('100');
                }

                // F3: Next search result
                if (e.key === 'F3') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        previousSearchResult();
                    } else {
                        nextSearchResult();
                    }
                }

                // Escape: Close modals
                if (e.key === 'Escape') {
                    closeWatermarkModal();
                    closeRangesModal();
                }

                // Ctrl+M: Toggle maximize
                if (e.ctrlKey && e.key === 'm') {
                    e.preventDefault();
                    toggleMaximize();
                }

                // F11: Toggle maximize (alternative)
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleMaximize();
                }
            });
        }

        // ===========================
        // PROGRESS INDICATOR
        // ===========================
        function showProgress(title, percent) {
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = Math.round(percent) + '%';
            document.getElementById('progressOverlay').classList.add('active');
        }

        function updateProgress(percent, title) {
            if (title) {
                document.getElementById('progressTitle').textContent = title;
            }
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = Math.round(percent) + '%';
        }

        function hideProgress() {
            document.getElementById('progressOverlay').classList.remove('active');
            document.getElementById('progressCancel').style.display = 'none';
            AppState.pdfExportCancelled = false;
        }

        function cancelPdfExport() {
            AppState.pdfExportCancelled = true;
        }

        // ===========================
        // TOAST NOTIFICATIONS
        // ===========================
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} active`;

            setTimeout(() => {
                toast.classList.remove('active');
            }, 3000);
        }

        // ===========================
        // ZOOM FUNCTIONS
        // ===========================
        // Zoom functions replaced with setZoomLevel() dropdown
        // Old zoomIn, zoomOut, resetZoom, applyZoom functions removed

        // ===========================
        // UTILITY FUNCTIONS
        // ===========================

        // Cache page positions after render
        let cachedPagePositions = [];

        function cachePagePositions() {
            const separators = document.querySelectorAll('.page-separator');
            cachedPagePositions = Array.from(separators).map(sep => ({
                pageNumber: parseInt(sep.dataset.page),
                offsetTop: sep.offsetTop
            }));
        }

        // Scroll detection for current page indicator
        let scrollTimeout;
        document.getElementById('reportDisplay')?.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                updateCurrentPageIndicator();
            }, 150);
        }, { passive: true });

        function updateCurrentPageIndicator() {
            // For large files using page-by-page rendering, don't update here
            // The page indicator is set by renderPageByPage() and should not be overwritten by scroll
            if (AppState.lines.length > LARGE_FILE_THRESHOLD) {
                return; // Page indicator is managed by renderPageByPage()
            }

            // Only update for small files using traditional full rendering
            const display = document.getElementById('reportDisplay');
            const scrollTop = display.scrollTop;

            if (cachedPagePositions.length === 0) {
                // Fallback to traditional method for small files
                const separators = document.querySelectorAll('.page-separator');
                let currentPage = 1;
                separators.forEach(sep => {
                    if (sep.offsetTop <= scrollTop + 100) {
                        currentPage = parseInt(sep.getAttribute('data-page'));
                    }
                });
                document.getElementById('currentPage').textContent = currentPage;
                AppState.currentPage = currentPage;
                return;
            }

            // Binary search for current page
            let left = 0;
            let right = cachedPagePositions.length - 1;
            let currentPage = 1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (cachedPagePositions[mid].offsetTop <= scrollTop + 100) {
                    currentPage = cachedPagePositions[mid].pageNumber;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            document.getElementById('currentPage').textContent = currentPage;
            AppState.currentPage = currentPage;
        }

        // ===========================
        // CURSOR POSITION TRACKING
        // ===========================
        function updateCursorPosition(row, col) {
            const indicator = document.getElementById('rulerCursorPosition');
            if (indicator) {
                indicator.textContent = `Ln ${row} Col ${col}`;
            }
        }

        function handleReportClick(event) {
            // Find the clicked line element
            let target = event.target;
            while (target && !target.classList.contains('report-line')) {
                target = target.parentElement;
                if (target === document.getElementById('reportDisplay')) {
                    return; // Clicked outside a line
                }
            }

            if (!target) return;

            // Get the page-relative line number
            const pageLineNum = parseInt(target.getAttribute('data-page-line')) || 1;

            // Calculate column position
            const lineContent = target.querySelector('.line-content');
            if (!lineContent) return;

            // Get click position relative to line content
            const rect = lineContent.getBoundingClientRect();
            const clickX = event.clientX - rect.left;

            // Calculate character width (monospace font)
            const fontSize = parseFloat(getComputedStyle(lineContent).fontSize) || 11;
            const charWidth = fontSize * 0.6; // Courier New character width approximation

            // Calculate column (1-based)
            const col = Math.max(1, Math.min(AppState.detectedWidth, Math.floor(clickX / charWidth) + 1));

            updateCursorPosition(pageLineNum, col);
        }

        // Handle mouse move for column highlighting
        function handleReportMouseMove(event) {
            const reportDisplay = document.getElementById('reportDisplay');
            const columnHighlight = document.getElementById('columnHighlight');

            if (!reportDisplay || !columnHighlight) return;

            // Use event delegation - traverse up from target
            let hoveredLine = event.target;
            while (hoveredLine && !hoveredLine.classList.contains('report-line')) {
                hoveredLine = hoveredLine.parentElement;
                if (hoveredLine === reportDisplay) {
                    columnHighlight.classList.remove('visible');
                    return;
                }
            }

            if (!hoveredLine) {
                columnHighlight.classList.remove('visible');
                return;
            }

            const pageLineNum = parseInt(hoveredLine.dataset.pageLine) || 1;

            // Cache font metrics to avoid repeated getComputedStyle calls
            if (!reportDisplay._cachedCharWidth) {
                const fontSize = parseFloat(getComputedStyle(reportDisplay).fontSize);
                reportDisplay._cachedCharWidth = fontSize * 0.6;
            }
            const charWidth = reportDisplay._cachedCharWidth;

            // Get the line content span (where actual text starts)
            const lineContent = hoveredLine.querySelector('.line-content');
            if (!lineContent) return;

            const lineContentRect = lineContent.getBoundingClientRect();
            const mouseXRelativeToText = event.clientX - lineContentRect.left;

            // Calculate column (1-based, accounting for text starting position)
            const col = Math.max(1, Math.floor(mouseXRelativeToText / charWidth) + 1);

            // Throttle cursor updates
            const now = Date.now();
            if (!handleReportMouseMove._lastCursorUpdate || now - handleReportMouseMove._lastCursorUpdate > 50) {
                updateCursorPosition(pageLineNum, col);
                handleReportMouseMove._lastCursorUpdate = now;
            }

            // Only show column highlight if enabled and mouse is over text
            if (AppState.columnHighlightEnabled && mouseXRelativeToText >= 0) {
                const highlightLeft = lineContentRect.left + (Math.floor(mouseXRelativeToText / charWidth) * charWidth);
                columnHighlight.style.left = highlightLeft + 'px';
                columnHighlight.style.width = charWidth + 'px';
                columnHighlight.classList.add('visible');
            } else {
                columnHighlight.classList.remove('visible');
            }
        }

        // Handle mouse leave to hide column highlight and reset position
        function handleReportMouseLeave() {
            const columnHighlight = document.getElementById('columnHighlight');
            if (columnHighlight) {
                columnHighlight.classList.remove('visible');
            }
            // Reset cursor position indicator
            updateCursorPosition(1, 1);
        }

        // Add click and mouse event listeners to report display
        function setupCursorTracking() {
            const reportDisplay = document.getElementById('reportDisplay');
            if (reportDisplay && !reportDisplay.dataset.cursorTrackingEnabled) {
                reportDisplay.addEventListener('click', handleReportClick);
                reportDisplay.addEventListener('mousemove', handleReportMouseMove);
                reportDisplay.addEventListener('mouseleave', handleReportMouseLeave);
                reportDisplay.dataset.cursorTrackingEnabled = 'true';
            }
        }

        // Set up tracking when DOM is loaded
        document.addEventListener('DOMContentLoaded', setupCursorTracking);
        // Also call it immediately in case DOM is already loaded
        setupCursorTracking();

        // ===========================
        // PRINT SUPPORT
        // ===========================
        function renderFullReportForPrint() {
            const display = document.getElementById('reportDisplay');
            const fragment = document.createDocumentFragment();

            let pagesToDisplay = AppState.pages;
            if (AppState.showRangesOnly && AppState.pageRanges.length > 0) {
                pagesToDisplay = filterPagesByRanges();
            }

            pagesToDisplay.forEach(page => {
                const separator = createPageSeparator(page.pageNumber, getSectionNameForPage(page.pageNumber));
                fragment.appendChild(separator);

                page.lines.forEach((line, idx) => {
                    const lineDiv = createLineElement({
                        ...line,
                        pageNumber: page.pageNumber
                    }, idx);
                    fragment.appendChild(lineDiv);
                });
            });

            display.innerHTML = '';
            display.appendChild(fragment);
        }

        // Detect print and render all content
        window.addEventListener('beforeprint', () => {
            if (virtualScroller) {
                // Temporarily render ALL lines for printing
                const display = document.getElementById('reportDisplay');
                display.classList.add('printing');

                // Destroy virtual scroller
                virtualScroller.destroy();
                virtualScroller = null;

                // Render full content
                renderFullReportForPrint();
            }
        });

        window.addEventListener('afterprint', () => {
            const display = document.getElementById('reportDisplay');
            display.classList.remove('printing');

            // Restore virtual scrolling
            renderReport();
        });

        // ===========================
        // ACCESSIBILITY
        // ===========================
        function setupAccessibilityNavigation() {
            const display = document.getElementById('reportDisplay');

            display.addEventListener('keydown', (e) => {
                if (!virtualScroller) return;

                const currentScroll = display.scrollTop;
                const lineHeight = 16;

                switch(e.key) {
                    case 'PageDown':
                        e.preventDefault();
                        display.scrollTop = currentScroll + display.clientHeight;
                        break;
                    case 'PageUp':
                        e.preventDefault();
                        display.scrollTop = currentScroll - display.clientHeight;
                        break;
                    case 'Home':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            display.scrollTop = 0;
                        }
                        break;
                    case 'End':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            display.scrollTop = display.scrollHeight;
                        }
                        break;
                }
            });
        }

        // Set up accessibility when DOM is loaded
        document.addEventListener('DOMContentLoaded', setupAccessibilityNavigation);

    </script>
</body>
</html>
